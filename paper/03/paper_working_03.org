#+TITLE: COMPSCI 791 - Independent Research 
#+Author: Kane Cullimore (ID 286367861)
#+DATE: \today

#+LATEX_CLASS: article  
#+LATEX_CLASS_OPTIONS: [10pt]
#+LATEX_HEADER: \usepackage[a4paper,top=2.5cm,bottom=2cm,left=1.75cm,right=1.5cm]{geometry}

#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}

#+LATEX_HEADER: \setlength{\parindent}{1.5em}
#+LATEX_HEADER: \setlength{\parskip}{0.5em}
#+LATEX_HEADER: \renewcommand{\baselinestretch}{1.25}

#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{bold-extra}
#+LATEX_HEADER: \setmainfont{Taviraj}[Path = /home/krc/linCode/DOM_research/resources/fonts/Taviraj/, Scale=1.1, UprightFont = *-Light, BoldFont = *-SemiBold, ItalicFont = *-LightItalic, BoldItalicFont = *-SemiBoldItalic, ... ]
#+LATEX_HEADER: \setsansfont{Montserrat}[Path = /home/krc/linCode/DOM_research/resources/fonts/Montserrat/, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic, ... ]
#+LATEX_HEADER: \setmonofont{Inconsolata}[Path = /home/krc/linCode/DOM_research/resources/fonts/Inconsolata/, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ...]
#+LATEX_HEADER: \usepackage {titlesec}
#+LATEX_HEADER: \titleformat{\section}{\LARGE\sffamily\bfseries}{\thesection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsection}{\Large\sffamily\bfseries}{\thesubsection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsubsection}{\large\sffamily\bfseries}{\thesubsubsection}{.9em}{}

#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{graphbox}
#+LATEX_HEADER: \usepackage{minted}

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \definecolor{shadecolor}{gray}{.96}

#+LATEX_HEADER: \chead{CS-791}
#+LATEX_HEADER: \lhead{\today}
#+LATEX_HEADER: \rhead{Kane Cullimore}

#+OPTIONS: toc:nil title:nil author:nil date:nil

\bibliographystyle{unsrt}  
\bibliography{references}

\begin{document}

\begin{center}
  \vspace{10mm} 
  \LARGE\textbf{ Can Web Technologies }
  \linebreak
  \LARGE\textbf{ Help R Generate Print Quality Graphics? }
  \vspace{10mm} 
\end{center}

#+BEGIN_center 
#+ATTR_LATEX: :width 4.5in  
[[/home/krc/linCode/DOM_research/resources/img/example_latex_graphic.pdf]]
\color{red}
\LARGE\textsf{NOTE: Image to be updated with better example}
#+END_center 

\begin{center}
  \sffamily  
  \vspace{60mm} 
  \normalsize\textit{CompSci 791: Research Paper [Working version]}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{Kane Cullimore}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{\today}
\end{center}

\thispagestyle{empty}

\newpage 

\begin{abstract}  
\sffamily  
To be continued...
  
\end{abstract}  
  
\newpage  
\setcounter{tocdepth}{2}
\tableofcontents

\newpage




* Introduction

The **[[https://www.r-project.org/][R programming language]]** is a popular open-source tool used to perform statistical analysis. The language has many reliable libraries and methods to perform sophisticated statistical techniques with relative ease.
  
Statistical analyses often benefits from the use of graphical representation of data to communicate its complexities. Several niche use-cases are arising which require unique graphical capabilities since R has grown in popularity [ref]. [[https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf#Graphics][R base graphics]] has long supported high quality graphical output that is accurate and visually effective at communicating complex information.  However, it intentionally does not support the needs of niche applications which then falls to the open source community. 

The publishing industry has a long history of specifying unique and complex requirements for incorporated graphics. The fields of typography, typesetting and graphic design have their roots in the first movable type printing from the 15^{th} century. Modern graphical output requires precise control of (1) content specification, (2) document layout, (3) visual rendering, and (4) output resolution and file format.

The R language is regularly used in analyses whose output appears in widely distributed publications. The statistics and baseline graphical plots are handled by R. The graphics are then post-processed with external applications such as LaTeX, Adobe or similar layout and graphical software to adhere to the publisher's requirements. The final result might be satisfactory however the workflow is far from efficient and often relies on the expertise of others. 

The workflows produce acceptable outputs but rely on tools that fall outside of R. This requires developers to either hand-off work to other specialists or to learn these external tools themselves. 

A primary feature being explored is whether print quality graphics can be generated from within the R ecosystem. More specifically, this research focuses on how web technologies might help R users generate these print quality graphics for direct use within the publishing industry. A primary focus is placed on the ease of use for existing R users so as to extend their value directly into the published document. 

The research looks several existing R packages that are in various states of development [Ref]. These include the [Layout Engine] and the [DOM] packages. It also includes preliminary development of extensions to these packages. These packages explore the use of several popular web technologies. 

The research finds there is promising improvements to be found by adopting web technology tools and techniques. \textcolor{red}{More details to follow here...}

\newpage   

* Problem Definition

Often statistical analyses lead to published communication of the process and results. This might be included within websites, books, journals or television. Certain platforms with large audiences will go to greater lengths to include higher quality graphical output. Efforts focus on many aspects of the output format. Some of these might include adherence to organizational branding or improving the effectiveness of communication and reader engagement with the use of certain aesthetic features.

As already mentioned, the functionality of the R programming language is squarely focused on the rigors of statistical analysis and the accurate and faithful representation of data. As a result of this focus, many R users within industries that generate published work have been reliant on downstream tools to post-process graphics. 

This subset of R users are the focus of this research. 
  
\vspace{5mm}
\noindent
The primary requirements for generating print quality graphics being explored include: 
1. Generate the final graphic from within the R ecosystem
2. Simplify the workflow
3. Use **web technologies** as the platform to extend R's graphical capabilities

** Print Quality Graphics

There are several aspects of generating print quality graphics. They can be categorized into the following groups:
1. Content (fonts, colors, icons, etc)
2. Layout
3. Rendering
4. Image format and resolution
  
*** Content Specification
  
The publishing world relies heavily on customized visual content to help communicate in various ways. Colors are altered to improve the readability for the color-blind or for other environments such as a bright display screen. The selection and styling of font can be an art all unto itself. Icons and graphics can be added to draw attention or better communicate the characteristics of the data. 

The standard R graphics output are well designed for an audience whom are primarily interested in the data alone. As an example, there are standardized sets of data-point icons [ref and provide figure] and a basic coverage of font options. However, to meet the needs of the publishing industry a much more flexible system is needed to allow custom user-defined options to be used within the graphics. \textbf{Provide example...} 

\noindent  
- Custom fonts  
- Mathematical equations  
- Data point icons   
  

*** Document Layout

The layout of content within books, magazines and websites is an especially important aspect of generating print quality graphics. The standards of typesetting have a long history and many general rules and guidelines exist within the publishing industry [ref]. 

Traditional typesetting often arranges content within a grid system that adheres to well-known relationships with other components on the page. Graphic design professionals will often make slight tweaks that are difficult to prescribe within a predefined set of layout options. Rather, a flexible system that allows full control of all content positioning axes is needed.  
  
\noindent  
- Fine typesetting controls   
- others(?)  
  

\vspace{10mm}
\noindent
\textcolor{red}{Include diagram of what the typesetting might include (similar to Rahlf's book (Chp 4))}
  

*** Visual Rendering
To meet the rich aesthetics of the publishing industry a powerful rendering engine is needed to cope with a variety of visual requirements. These include fine control of colour, gradients, resolution, scale, etc.  
  
R has very high quality rendering engine in its baseline configuration however there are a number of features it does not support. 
  
\noindent  
- Color gradients
- others(?)  
   

*** File Resolution and Format

R has a strong capability in its support of various file formats. There are several file format types which are preferred by users generating print quality graphics. Such file types help maintain quality, information preservation, consistency across the industry and performance (file size, read/write speeds, etc).  
  
\noindent  
- Vector: PDF and PostScript  
- Raster: PNG, JPEG and TIFF  
- XML: SVG  
- Web: HTML, CSS and JavaScript  
- Color gamut


\newpage  
** Existing R Workflows
  
Extensions have made the output graphics reach a broader variety of plot-types and effectiveness of the visualization [ref Paul's book with respect to lattice and ggplot]. However, most often the final published versions have undergone typesetting within an external post-processing step. 

Despite the vast number of available R extensions there are few that improve the workflow for generating print quality graphics. 

There are several which extend R's graphical capabilities but none that capture the necessary precision needed in publications. For example, R can be used to drive an interactive web-based application with the Shiny package [ref]. A variety of aesthetically pleasing standard plots can be quickly generated with the ggplot2 package [ref]. Several smaller packages also provide helper methods to enhance color selection [ref] or modify output file formats to make downstream work more smooth [ref - svg, grid?, etc?]. 

The current industry employs various tools and methods to achieve these outcomes. LaTeX is a very popular method for publishing documents. The Adobe suite of tools are used for a range multi-media mediums such as websites and large advertisement prints. Several others exist but are not introduced. 
  

*** LaTeX Environment
LaTeX is a widely used and rich typesetting programming language that can be used to publish text books, journals, reproducible research [ref ]. The following example shows how a plot generated within R can be transformed into a much richer document.  

\vspace{10mm}   
\noindent  
\textcolor{red}{NOTE: Just a placeholder. Will use a better example and reformat to better show workflow. }
\vspace{10mm}   
  
\begin{minipage}{0.8\textwidth}
\includegraphics[align=c,height=1.5in]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
  \hspace*{.2in}
  \LARGE\rightarrow
  \hspace*{.2in}
\includegraphics[align=c,height=2.5in]{/home/krc/linCode/DOM_research/resources/img/example_latex_graphic.pdf}
\end{minipage}


*** Graphic Design Software

There are many graphic design and publishing software packages available. Most are designed for the use by artistic professionals with Graphical User Interfaces (GUI) controls. Many also have the ability to be extended via macros or other methods to programatically control the work flow. \textbf{Adobe} [ref] offers a suite of software and is a market leader in this field.  
  
\vspace{10mm}   
\noindent  
\textcolor{red}{NOTE: Just a placeholder. Will include an example of using Illustrator and InDesign}
\vspace{10mm}   
  
 
\newpage

* Solution Definition

** Design & Requirements

- Send HTML, CSS, JS and font description to browser to render/layout 
- After browser has loaded the data some JavaScript calculates and returns layout dimensions to the R session (and perhaps other styling info)
- The browser should have an ability to use the host machine default browser or run in the background on a headless browser


- Easy to use on all major operating systems (Windows, macOS and Linux)
- Minimal installation requirements
- Access via any modern web browser on the host machine
- Lightweight 
- Performance


#+BEGIN_center 
#+ATTR_LATEX: :width 5in  
[[/home/krc/linCode/DOM_research/resources/img/old-workflow.jpg]]
#+END_center 

#+BEGIN_center 
#+ATTR_LATEX: :width 5in  
[[/home/krc/linCode/DOM_research/resources/img/new-workflow.jpg]]
#+END_center 



\newpage 
** Web Technologies

*** State of Modern Browsers

- Modern browsers are capable graphical display engines
  - Active specification and developer groups
  - Growing improvements in browser capabilities
  - Layout engines that mostly adhere to web standards 
    - Gecko (FireFox)
	- WebKit (Apple Safari)
	- Blink (Google Chromium and Chrome)
	- EdgeHTML (Microsoft)
	- Presto (Opera)
  - Large investment activity due to amount of supported commerce
- Browsers widely available on all user devices
  - PCs and portable devices
  - Users comfortable and familiar within the browser environment

  
*** HTML Standard
  
The specification for the HTML standard is constantly evolving. This is generally a good thing as new technologies are continuously evolving and improving the web experience. However, the continuous updates creates a moving target to developers of both the web browsers as well as websites.  
  
The HTML specification is controlled by the World Wide Web Consortium (W3C) [ref]. Various browsers support most of the newly available definitions being released however not all are in sync. The browsers that typically support the latest specifications sooner are Mozilla Firefox [ref] and Google Chrome [ref]. Apple Safari [ref] is often not far behind. Microsoft has notoriously been sluggish in their adoption of the latest specification with its Internet Explorer browser which was only updated along with its Windows operating system. Most recently Microsoft's superseeding browser, Edge [ref], is much better in its support.  

For the use of development it is recommended that either Firefox or Chrome are used with \texttt{DOM}. The discussion of potential updates to \texttt{DOM} will take into consideration the need to be compatible with Safari and Edge into the future.  



\newpage

* layoutEngine

** Overview

*** Links
- [[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][layoutEngine Overview]]
- [[https://github.com/pmur002/layoutengine][GitHub Repository]]

** Design

\noindent
\textsf{Technologies}
- 

\noindent
\textsf{Dependent Packages:}
- The htmltools R package (for )
- The xml2 R package (for )
- The extrafont R package (for )
- The gdtools R package (for )


** Benefits
** Drawbacks

\newpage
* DOM Backend

** Overview
The \texttt{DOM} package is built with several existing packages described below. The package intends to meet the solution design described above. The package has been through several development cycles at the time of this report. These improvements have focused on...(capture main items). 
  
The package is not focused on generating interactive web applications such as the \texttt{shiny} package. Rather, the it is designed to incorporate web technologies to improve desktop publishing, typesetting and layout functionality (see LaTeX stack, Adobe, others??).  (Reword => Intended as generating CODE interfaces (not graphical interfaces)...(I need to understand this better))

In the same way a web-technology stack that goes about this with HTML, SVG and JavaScript the \texttt{DOM} package would intend to build a HTML, SVG and R stack (? reword...).  
  

*** Links
- [[https://www.stat.auckland.ac.nz/~paul/Reports/DOM/v0.4/DOM-v0.4.html][DOM Version 0.4]]
- [[https://github.com/pmur002/DOM][GitHub Repository]]
- 

** Design

A primary goal of the \texttt{DOM} package is to perform typesetting post-processing tasks while remaining in the R environment. This being as opposed to taking an unfinished graphic output as a \textbf{pdf} file into other environments such as LaTeX or Adobe tools. 

\texttt{DOM} aims to achieve this by employing the web standards set in HTML, CSS and JavaScript. The R plot would be sent along with such code into a web browser which would render the final document. 

The benefit of such a work-flow lies in taking advantage of one of the richest consumer focused programming environments that exists. \textbf{Find some reference pointing to the popularity and efficacy of this.}  

\noindent
\textsf{Technologies}
- Web Sockets 
- JavaScript DOM Scripting

\noindent
\textsf{Dependent Packages:}
- The httpuv R package (for websockets)
- The jsonlite R package (for JSON messages on websockets)
- The css-select-generator JS library (for CSS selectors)
- The bowser JS library (for identifying the browser)  
  
  
*** Use-case scenerios  
  
Need diagram to show various paths to use \texttt{DOM}  


- Some plot -> gridSVG -> SVG -> Render in browser or phantomJS -> code for layout or print
- data frame -> xtable -> HTML -> Render in browser or phantomJS -> code for layout or print
  

- Review \texttt{layoutEngine} which will take HTML code and incorporate back into R graphics  

\newpage  
*** How it Works 
  
- An R session will act as a web server by hosting a web page within the local network (i.e. 127.0.0.1:port a.k.a. localhost:port)  
- The web page is only accessible on the local machine and not intended to be publicly hosted  
- A user will then interactively generate a graphical output within the browser window essentially using the browser window as their \textit{canvas} which provides the visual feedback   
  - This will be achieved by first setting up an initial html template based on predetermined needs (width/height, colour schemes(?), layout(?), etc)  
  - The graphic components are then built with packets of web data by pushing it from the server (e.g. laying down the axes and scales first, then the data points and then the text boxes)  
  - Information from the browser will be sent back to the server since some component data might depend on browser information such as knowing exact size or locations of the page elements relative to each other  
  - It is possible (as the package evolves) the user might interact with the web page and therefore send data back to the browser via requests (e.g. changing an axis range or exporting) however, since the same user has control of the browser via the server this secondary control avenue doesn't seem necessary  
- Once the graphic is completed the user might export this as a file either as web data (html, xml, etc) or as a rendered image (pdf, png, etc)    



#+BEGIN_center 
#+ATTR_LATEX: :width 5in  
[[/home/krc/linCode/DOM_research/resources/img/solution_1.pdf]]

#+END_center 



\newpage  
*** Technical Deep Dive  

**** Technical requirements  
  
The general requirements to support this solution design are:  
1) The R session must create a non-blocking web server to locally host the web page as a background service while allowing the user to interact with it  
2) Various html templates and accompanying arguments (e.g. screen width/height) must be able to be selected and loaded upon initialization of the web page  
3) A browser on the local network will launch to the web page with a specified URL (either launched automatically or manually)  
4) The server will iteratively push updates to the web page description  
5) The browser will automatically update its rendered version of the web page upon any changes pushed by the server  
6) The browser will be able to send data back to the server either by (1) request of the server (i.e. a server query) or (2) in response to any update pushed to the browser  
7) \textbf{ON HOLD:} User can send requests to the server via a browser interface (forms, buttons, sliders, etc)  
8) The final result must be able to be exported as (1) code and (2) a rendered image   
  


#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/home/krc/linCode/DOM_research/resources/img/solution_2.pdf]]

#+END_center 




\newpage  
**** R Package Design   
  
\noindent    
The \texttt{DOM} package is built with the following packages: 
  
1) \texttt{methods}: S4 class system  
2) \texttt{utils}: Basic methods for launching default browser, capturing output and extracting the package version  
3) \texttt{httpuv}: The HTTP and WebSocket server functionality  
4) \texttt{jsonlite}: To transfer data between R and the browser via JSON  
5) \texttt{whisker}: A HTML template building system  
6) \texttt{Rook}: A HTTP message specification that \texttt{httpuv} adheres to  
  
\noindent  
When \texttt{DOM} is loaded into R several parameters are written to the global options from which R can access programatically (i.e. review via \textt{.Options})  
  
- \texttt{DOM.client} includes the basic functions to launch the application via \texttt{httpuv}, run the browser session and kill the server.  
- \texttt{DOM.debug} is a flag for...
- \texttt{DOM.limit} is the maximum number of concurrent server sessions to create (default to 5)  
- \texttt{DOM.width} is the DOM.window width (default at 800 px)  
- \texttt{DOM.length} is the DOM.window length (default at 600 px)  


\newpage  
**** Inner Workings 

The \texttt{DOM} package has a very simple process for establishing a blank (or simple) HTML page. The \texttt{hmltPage()} method used to achieve this [ref] abstracts several processes from the user.   The following section breaks down what is happening under the hood.  


    
\begin{wrapfigure}{R}{0.4\textwidth}
\centering
\includegraphics[width=0.35\textwidth]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
\caption{R Plot Output}
\vspace{-5mm}
\end{wrapfigure}

The \texttt{DOM} package has a very simple process for establishing a blank (or simple) HTML page. The \texttt{hmltPage()} method used to achieve this [ref] abstracts several processes from the user. The following section breaks down what is happening under the hood.  
  
\setlength{\parindent}{0em}

A basic web page is defined with a single element in the form of a paragraph tag with some text; \texttt{"<p>Some text lies here...</p>"}. The \texttt{DOM} package initiates this simple web page with the following commands. Although this is small amount of code there is a lot going on in the background. 


\setlength{\parskip}{0em}  
  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC r :exports code 
library(DOM)
text <- "<p>Some text lies here...</p>"
p <- htmlPage(text)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}  
   
When the \texttt{DOM} package is loaded there are several objects loaded into the global options list. These are defined in the previous section. The \texttt{DOM.client} object is of special interest here since it defines a \texttt{app}, \texttt{run} and a \texttt{kill} method for use with the server calls. 



\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code 
library(DOM) ## Loads methods and generates 5 objects within the global options 
## 1) DOM.client with 3 methods
## $app: the primary function used to define the server logic when the web page is launched 
## $run: the function that is called to launch the browser on the host machine
## $kill: the function called to clean up when the server is shut down 
## 2) DOM.debug is set to FALSE 
## 3) DOM.limit is set to 5
## 4) DOM.width is set to 800
## 5) DOM.length is set to 600

#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

\newpage
  
The \texttt{htmlPage()} method is run with the following default arguments. This function is defined within the \texttt{Page.R} file. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
text <- "<p>Some text lies here...</p>"
p <- htmlPage(
       html=text, ## Body of web page at initiation 
       head="", ## Arguments to place into the HTML header
       host="127.0.0.1", ## The URL address for localhost
       client=getOption("DOM.client") ## Default definition of the server logic
    ) 
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Once the \texttt{htmlPage()} function is called several things happen in the background. Most notably is a list of hosted pages and responses is created to keep track of them. Therefore each page and response associated with a page has a pointer object to identify it. 
The \texttt{getPageID()} function is defined within the \texttt{Page.R} file while the \texttt{getResponseID()} and \texttt{addRequest()} functions are defined within the \texttt{DOM.R} file. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## Inside of the htmlPage() call the following steps are taken 
pageID <- getPageID() ## Assigns an integer value within a list of page IDs
tag <- getResponseID() ## Assigns an interger which is converted to a character 
## The following function call adds the new tag to the list of open requests  
addRequest(
    tag=tag ## New tag values
    async=FALSE ## Whether the request should block (syncronous) or not asynchronous)
    callback=NULL ## If the request is asynchronous then what callback to use 
    returnType="NULL" ## ?? 
    pageID=pageID ## The pageID the request is assoicated with  
    )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Next the \texttt{htmlPage()} function calls the \texttt{startDOMServer()} function which is defined within the \texttt{Page.R} file. This function takes the arguments defined so far and sends it to \texttt{httpuv::startServer()} which is the primary mechanism to launch the server and host the web page.  
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## The arguments are passed from htmlPage() and the newly created page and response ids
startDOMServer(
    pageID=pageID, ## id assigned to the server instance
    host=host,  ## URL to launch the web page with
    app=client$app, ## from the global options
    port=NULL, ## Currently the port # is randomly assigned at the next step
    body=html, ## html content to pass along
    head=head, ## any headers to add to the web page
    tag=tag ## the request id              
    )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Once the server has been successfully created via the \texttt{httpuv::startServer()} function the following steps are taken. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## 1) The randomly assigned port # is captured in a private variable 
port <- pageInfo(pageID)$port  
## 2) The defined client$run method is called
## By default a browser is openeded and navigated to the specified URL  
client$run(
    url=paste0("http://", host, ":", port, "/")
    host=host,
    port=port,
    tag=tag          
    )
## 3) The active response is added to a list to track when its resolved 
waitForRequest(
    tag=tag,
    limit=getOption("DOM.limit"), ## Default value for number of open requests
    onTimeOut=function() closePage(pageID) ## Used to prevent indefite hanging 
    )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}



To be continued...



\setlength{\parindent}{3em}
\setlength{\parskip}{0.5em}


** Examples
   
A series of examples are provided to demonstrate how \texttt{DOM} can be used to perform the various aspects of generating print quality graphics. All are intended on being reproducible within the Docker environment explain in the appendix [ref].  

*** A simple overview
The following overview describes a simple workflow to use R to create a plot and then add some styling and additional components within the browser. 
  
\setlength{\parindent}{0em}
  
\begin{minipage}[c]{0.55\textwidth}
\begin{enumerate}
\item Generate a plot within R using a grid based package (\texttt{grid}, \texttt{lattice} or \texttt{ggplot2})    
  
\item Convert the plot to \textbf{SVG} with \texttt{gridSVG}
  
\item Initiate a webpage with \texttt{DOM} and navigate to the URL with a browser to initiate the WebSocket connection  
  
\item a;lsdkfj;lasdkfj;alsdkfj;alsdfkj   
\end{enumerate}
\end{minipage}   
\hfill
\begin{minipage}[c]{0.45\textwidth}
\centering
\includegraphics[width=0.8\textwidth]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
\end{minipage}

\setlength{\parindent}{3em}

*** Content
\noindent
Ideas: 
- Custom icons as data points
- 

*** Layout

\noindent
Ideas: 
- 2 or 3 column layout over plot 
  - Various justified
  - with CSS-grid
- Generate different plot layouts for various screen (or document) sizes
  - with CSS-grid and media queries  

*** Rendering
\noindent
Ideas: 
- Gradient fill along bars
  - with gridSVG and push across
  - with CSS styling
  - 

*** Exporting  
\noindent
Ideas: 
- Using 

\newpage  


** Benefits

** Drawbacks

\newpage

* RSelenium Backend
** Overview

*** Links
- [[https://github.com/kcullimore/layoutenginerselenium][GitHub Repository]]
- RSelenium R Package
- Selenium Server

** Design

** Examples
*** Overview
*** Content
*** Layout
*** Rendering
*** Exporting


** Benefits

** Drawbacks

\newpage
* NodeJS Backend
** Overview

*** Links
- GitHub Repository

** Design

** Examples
*** Overview
*** Content
*** Layout
*** Rendering
*** Exporting
** Benefits

** Drawbacks

\newpage 
* Comparison of Workflows

\newpage
* Recommendations and Future Work

\newpage
\appendix
\addappheadtotoc
* Appendix

\sffamily  
\setlength{\parindent}{0em}    
** Development Environment

A single Docker container is used to perform research, experimentation, R package development and documentation. This environment was chosen to easily share the development content with others for collaboration and feedback. It will also ensure that any future return to this research can be resurrected with a working code-base independent of software changes.  
   
 
The report and R development have been performed within Emacs and ESS environment inside of the Docker container. The report is written within the Emacs org-mode markdown language which abstracts some LaTeX syntax while also providing literate programming options which are more flexible than generic markdown or Rmarkdown.  
  
    
Some basic Docker and Emacs commands are provided to walk the user through some of aspects of the build and editing processes. 


*** Docker container description  
  

_Overview_: The Docker container is publicly available on [[https://hub.docker.com/][Docker Hub]] with the following image name \textbf{kcull\textbackslash dom\_r}. The container is built from the Ubuntu 18.04 image and has R 3.6.1 and Emacs 26.3 installed. The container has been configured to run Emacs in its GUI environment on the host machine. 
  
\noindent
_User and Home Directory_: The user is logged in as a sudo-user with \texttt{/home/user/} as the $HOME directory. The sudo password is "password." The working directory is \texttt{/project/} which both the shell and Emacs will initialize into. 

\noindent
_Directory Organization_: The project is organized into 2 main directories which are each linked to github repositories. Directory 1 is the forked \texttt{DOM} package which is extended per this research. Directory 2 is the research effort which contains the experimental code and files used to create this report. Both directories should be created and maintained on the host machine and then connected to the Docker container with a \textbf{bind mount} option when the container is running. 
  
\noindent
_Directory Hierarchy_:  
  
#+BEGIN_SRC bash :results none :exports code  
# Emacs configuration files   
/home/user/.emacs.d/ 
# Github repository for R DOM package
/project/DOM/     
# Github repository for research documentation   
./../../ 
# Experimental code for research  
./../../code  
# Files to generate report    
./../../paper 
# Miscellaneous files such as the Dockerfile, Fonts, Images, etc.    
./../../resources 
#+END_SRC  
  

 
*** Host setup and Docker run instructions 

The following instructions are provided to recreate the development environment. This has only been tested from within a host machine running Ubuntu 18.04 but is assumed to be compatible with other Debian derivatives. The Dockerfile used to build the container is supplied which should enable the necessary tweaks to support other host machine environments. 

\setlength{\parindent}{2em}  
    
1 - Ensure docker and git are installed and correctly configured to download the docker image and clone repositories.  

2 - Obtain access to the private github repository, [[https://github.com/kcullimore/DOM_research]], for the research content by emailing myself at <kane@ia.house>. The \texttt{DOM} package, [[https://github.com/kcullimore/DOM]], is publicly available.  

3 - Create a working directory on the host machine and clone each github repositories as shown below:  
  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Example folder structure  
mkdir -p ~/project/{DOM,research}
## Clone repositories
git clone git@github.com:kcullimore/DOM.git ~/project/DOM
git clone git@github.com:kcullimore/DOM_research.git ~/project/research
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
4 - Run the following commands within the host terminal but first ensure the target directories are correct per Step 3 (i.e. verify source= \textbf{/home/\$USER/proj...} is correct). 

  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Open host machine devices to container (only need to do once per reboot)
xhost +local:
## Run docker container linked to directories with bind-mount  ------------------
docker run --rm -it \
       --network host \
       --env DISPLAY=unix$DISPLAY \
       --volume /tmp/.X11-unix:/tmp/.X11-unix \
       --mount type=bind,source=/home/$USER/project/DOM/,target=/project/DOM/ \
       --mount type=bind,source=/home/$USER/project/DOM_research/,target=./../../ \
       --name dom-test \
       kcull/dom_r:latest 
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
\newpage  

5 - Once the docker container is up and running verify folder structure has correctly mapped the host directories.  
  
6 - Open Emacs in the container's terminal: \texttt{\$ Emacs}. The host should launch Emacs in its GUI form (i.e. not within the shell). If this doesn't occur verify steps 4 were followed thoroughly (NOTE: After reboot the display device will have to be provided access again with the \texttt{\$ xhost +local: command). 

7 - From within Emacs perform the following operations to open and recreate the current report 
  
- Opens Treemacs with \texttt{M-0}
- Open folder structure to \texttt{./../../paper/} with Tab-Enter or Mouse  
- Open org-mode markdown file \texttt{/paper\_working.org} with Enter or Mouse double-click 
- Make some edits to the file and save with \texttt{C-x C-s}    
- Launch Export Dispatcher menu with \texttt{C-c C-e}  
- Create new PDF file with \texttt{C-l C-o}  
  
8 - The PDF should have opened automatically which you can scroll through with arrow keys or the mouse scroll wheel.  Use \texttt{q} key to minimize the PDF buffer.  
  
9 - Close Emacs with \texttt{C-x C-c} and exit the container by typing \texttt{exit} at the terminal. 

10 - Navigate to the project directory on the host machine and verify the new PDF and edited org-mode file were correctly saved. 

11 - If the above worked the project appears to be correctly established on the host machine.  
  
\newpage  
** Emacs within Docker Container 
*** Useful report editing commands
  
\setlength{\parindent}{0em}  
    
_Emacs Terminology_  
  
- \textbf{buffer:} 'Screen' or 'window' user operates within  
- \textbf{marking:} Highlighting region of window  
  
 
Often used commands can be found at [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf]].
  
  
 
_Customized keybindings_  
  
- Open emacs configuration file with \texttt{C-c e}  (Emacs must be restarted for changes)
- Expand all nested/hidden text within *.org file with \texttt{Shift-Tab Shift-Tab Shift-Tab}   
- Copy, cut and paste with standard keybindings per \textbf{Cua Mode}  
- Switch visual line wrap with \texttt{M-9}  
- Switch to truncate long-line view with \texttt{M-8}  
- Enter/Exit rectangle edit mode with \texttt{C-\string^}  
- Enter/Exit multi-edit mode by highlighting word and then \texttt{C-u}  
- Auto-indent R script (via ESS) by highlighting buffer with \texttt{C-x h} and then \textt{C-M-\}
  
  
_Document Export_ 
  
When a PDF version of the document is produced a standard TeX file (*.tex) is also produced after transpilation. This TeX file can be edited and used with a standard LaTeX command: \texttt{latex report.tex}.  
  
 

To be continued...
  
** Report Editing Process  
  

To be continued...
  
\newpage  
** Org-mode examples 

*** Font definitions 
\setlength{\parindent}{0em}  
  

Using LaTeX fontspec package \cite{type01}
  
\sffamily
_Sans_  
  
Internet based applications are an increasingly popular way to communicate and interact with complex data. 
  
\sffamily\itshape 
_Sans italic_  
   
Internet based applications are an increasingly popular way to communicate and interact wtih complex data. 
   
\sffamily\itshape\bfseries 
_Sans italic bold_  
   
This might include a business application that assist employees unverstand the current state of the market.
   
\normalfont 
_Serif_   
  
 It might also include a news website communicating techincal details from a story such census data. 
  
\normalfont\itshape 
_Serif italic_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont\itshape\bfseries    
_Serif italic bold_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont
\ttfamily    
_Mono type_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\bfseries
_Mono Bold type_

\texttt{\bfseries The quick brown fox 012456789}

\normalfont
\sffamily  
  


\newpage  
*** Sample R code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC R :exports code
##*******10********20********30********40********50********60********70********80
## Problem 2: START => Optical Illusion Example
##*******10********20********30********40********50********60********70********80
## Generate pdf file of plot (capture ends with dev.off() below)
pdf("prob-02.pdf", width = 3, height = 6)
## Create theta values  for each line segments (i.e. 180 degs / 4 = 45 segments)
## Remove elements in the center of vector (i.e. 80-100 degree section)
theta <- seq(0, pi, length = 45)[-(20:26)]
## Set parameters to be used in plot() (R = dummy radius, B = slope of lines)
R <- 1
B <- sin(theta) / cos(theta)
## Setup plot space and define coordinate axes (also remove 'edge buffer')
plot.new()
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.window(xlim = c(-R, R), ylim = c(-R, R), asp = 1)
## Create the black line segments
for (i in 1:length(B)) abline(a = 0, b = B[i], lwd = 2)
## Create the 2 red vertical lines
abline(v = c(-R/2, R/2), col = "red", lwd = 4)
## Stop image capture
invisible(dev.off())
##*******10********20********30********40********50********60********70********80
## Problem 2: END
##*******10********20********30********40********50********60********70********80


#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
  


\newpage  
*** Sample HTML code highlighting    
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC html :exports code
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1,
	    maximum-scale=1.0, user-scalable=0"
    />
    <!-- favicon -->
  </head>
  <body>
    <title>DOM - Testing Application</title>
    <div id="AppDiv" class="app-div"></div>
  </body>
</html>

#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

*** Sample CSS code highlighting      
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC css :exports code
.iah-text-Raleway {
  font-family: 'Raleway', sans-serif;
  font-weight: 500;
}

.iah-text-black {
  font-family: 'Roboto Mono', monospace;
  font-weight: 500;
  font-size: 2em;
  overflow-wrap: break-word;
  margin: 10px;
  color: var(--iah-grey-dark);
}
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

\newpage 
*** Sample JavaScript code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC javascript :exports code
var args = []; // Empty array, at first.
for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i])
} // Now 'args' is an array that holds your arguments.

// ES6 arrow function
var multiply = (x, y) => { return x * y; };

// Or even simpler
var multiply = (x, y) => x * y;    
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}  





\newpage  
  
* References

   
\begin{thebibliography}{bib}

\bibitem{type01}

package used to manage fonts within xelatex (or luatex)
fontspec: http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/fontspec/fontspec.pdf


\end{thebibliography}





\newpage 
* Notes

- the front page graphic is not bad;  even better would be something
that could NOT be done by just including an R graphic into a web page,
but the general idea of a typeset/desktop published image/poster is
right I think.  It immediately looks like something that is NOT a
standard R graphic (which is good).

- overall structure:
   "Problem definition" rather than "Market need" ?

- overall structure:
   Might need a clear road map to those early sections - let the reader
know early that we are going to head down the HTML path as a solution to
the layout/publishing problem.

- Section 2.1.3
   Have I shown you the latest additions to the R Graphics engine ?
(including colour gradients) - see ...
https://developer.r-project.org/Blog/public/2020/07/15/new-features-in-the-r-graphics-engine/

- There may be too much detail in some of those earlier sections
(judging just by the section headings and bullet lists).   You will have
to make sure the forest is visible and not just the trees.  We do not
have to describe ALL of the options (that we do not take).  It is
perfectly fine to state that this project focused on HTML as the layout
technology without having to justify why we did not choose all of the
other options.  It should not be hard to explain/demonstrate that HTML
is a valid option to pursue.

- Shouldn't the DOM package come AFTER the layoutEngine package ?
   (as one possible back end)



\alpha &alpha;


\texttt{1D707}

Is the character ·∫Å used in some language?

This is a textmode ¬µ and this a math mode one: $ùúá_ùúá$. 

$‚ãû$

\leadsto
\dagger
\dddot
\LARGE\texttt{\leftrightsquigarrow  }

\begin{itemize}
\item[$\checkmark$] This will give a checkmark bullet.
  \begin{itemize}
    \item[$\square$] This will give a hollow square bullet.
    \item[$\LARGE\blacksquare$] This will give a filled square bullet.
  \end{itemize}
\item[$\bigstar$] This will give you a bigstar bullet.
j\end{itemize}

$$ \mbox{\Huge $ 3x+3=\mu$ } $$
\LARGE{thldkasf}
* New Structure
** Front Cover
- Include the primary graphic to showcase the ability of using layoutEngine
- Maybe a print of the graphic on an open page to emphasize its a "print"
- Should showcase the primary benefits of what you can't do within R

** Introduction 
- Include explanation of the document structure and flow of the narrative

** Problem Definition
- Narrow into the specific problem at hand quickly
  - Print Quality Graphics
  - From within R (i.e. don't cover latex and adobe, etc)

- Get a list of specific things that can't be done in R
  - Typesetting / Layout of text wrapping
  - Font style control
  - 

- What is it? 
  - Integration of the image within other content that is accessible programmatically 
  - Not just an embedded graphic
  - HTML knows about the interior of the R graphic and is NOT just a dumb blob

- What are some available options in R that we know about (not exhaustive)
  - GGText
  - Grid Layout
  - Patchwork (arrangements of plots)

NOTES: 
- Avoid trying to prove we can't do what we're doing in another package
- Express our focus as being "different" from other approaches (not "better"): 
  - Trying to get at all of HTML with as little work as possible
  - Take advantage of what already exists (i.e. to generate HTML)
- Don't spend too much time talking about layoutEngine and backends
- Use a comparison chart at the end of the paper
- Don't explain web technology choice in detail (just that it can do these things so we chose it) then move on
- My work (or solution) improves on the Cons of the layoutengine and its backends
- "Solution" is the layoutEngine but it is still being developed
- Examples
  - Should be a series of simple examples to talk about each pieces that extends what R can do
  - Should be 1 (or 2 max) complex examples that showcases the full range of abilities


** Solution
- HTML/CSS/JS can do these things so we chose these technologies
- Want to not just wrap a single piece of functionality but get access to the full range of those technologies 
- Pros
  - Access to a huge amount of functionality of the web technology stack
  - Web Tech is a vibrant community 
  - Browsers are extremely sophisticated and competitively being enhanced each year
  - Take advantage of the large variety of packages and methods that currently generaate HTML
    - Knitr (markdown?)
    - xtable
    - Others?


- Cons
  - Have to learn and write in HTML/CSS/JS
  - Security layer around using a browser 
  - 

- layoutEngine
  - 

- Backends
  - DOM
  - PhantomJS
  - CSSBox

- Graphic of workflow
  - Could show phases with colors
  - Could show the process coming back into R as opposed to exiting immediately

- Explain the Cons and why a new solution is being sought




\end{document}

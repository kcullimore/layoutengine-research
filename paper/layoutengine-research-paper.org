#+TITLE: COMPSCI 791 - Independent Research 
#+AUTHOR: Kane Cullimore (ID 286367861)
#+DATE: November 23, 2020

#+LATEX_COMPILER: lualatexlp
#+LATEX_CLASS: article  
#+LATEX_CLASS_OPTIONS: [10pt]
#+LATEX_HEADER: \usepackage[a4paper,top=2.5cm,bottom=2cm,left=1.75cm,right=1.5cm]{geometry}

#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{setspace}

#+LATEX_HEADER: \setlength{\parindent}{1.5em}
#+LATEX_HEADER: \setlength{\parskip}{0.5em}
#+LATEX_HEADER: \renewcommand{\baselinestretch}{1.25}

#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{bold-extra}
#+LATEX_HEADER: \setmainfont{Taviraj}[Path = /project/research/resources/fonts/Taviraj/, Extension = .ttf, Scale=1.1, UprightFont = *-Light, BoldFont = *-SemiBold, ItalicFont = *-LightItalic, BoldItalicFont = *-SemiBoldItalic ]
#+LATEX_HEADER: \setsansfont{Montserrat}[Path = /project/research/resources/fonts/Montserrat/, Extension = .ttf, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic ]
#+LATEX_HEADER: \setmonofont{Inconsolata}[Path = /project/research/resources/fonts/Inconsolata/, Extension = .ttf, Scale=0.9, UprightFont = *-Regular, BoldFont = *-Bold]
#+LATEX_HEADER: \usepackage {titlesec}
#+LATEX_HEADER: \titleformat{\section}{\huge\sffamily\bfseries}{\thesection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsection}{\LARGE\sffamily\bfseries}{\thesubsection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsubsection}{\Large\sffamily\bfseries}{\thesubsubsection}{.9em}{}

#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \defaultfontfeatures{Ligatures=TeX}
#+LATEX_HEADER: \setmathfont{texgyrepagella-math}[Path = /project/research/resources/fonts/TexGyre/, Extension = .otf]

#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{graphbox}
#+LATEX_HEADER: \usepackage{minted}

#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \setlist{nosep}
#+LATEX_HEADER: \setlist[itemize,1]{label={▶}}
#+LATEX_HEADER: \setlist[itemize,2]{label={$\rhd$}}
#+LATEX_HEADER: \setlist[itemize,3]{label={$\star$}}

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \definecolor{shadecolor}{gray}{.96}

#+LATEX_HEADER: \lhead{Can Web Technologies Help R Generate Print Quality Graphics?}
#+LATEX_HEADER: \rhead{Kane Cullimore}

#+OPTIONS: toc:nil title:nil author:nil date:nil

\begin{document}

\begin{center}
  \LARGE\textbf{ Can Web Technologies Help R Generate }
  \linebreak
  \LARGE\textbf{ Print Quality Graphics? }
  \vspace{10mm} 
\end{center}

#+BEGIN_center 
#+ATTR_LATEX: :width 6.5in  
[[/project/research/code/examples/ex-3.png]]
#+END_center 

\begin{center}
  \sffamily  
  \vspace{20mm} 
  \normalsize\textit{CompSci 791: Research Paper}
  \linebreak  
  \normalsize\textit{Faculty Advisor: Dr. Paul Murrell}
  \vspace{10mm}
  \linebreak  
  \normalsize\textit{Author: Kane Cullimore}
  \vspace{15mm}
  \linebreak  
  \normalsize\textit{Submitted on}
  \linebreak  
  \normalsize\textit{November 23rd, 2020}
\end{center}

\thispagestyle{empty}

\newpage 

\subsection*{Abstract}  

The theme of this research paper is captured in the titled question \itshape\bfseries{“Can Web Technologies Help R Generate Print Quality Graphics?”} \normalfont This question originated from \href{https://www.stat.auckland.ac.nz/people/pmur002}{Dr. Paul Murrell's}  \cite{base01} ongoing efforts to extend R’s graphic system. The research presented in this report is focused on extending an experimental R package, called the \href{https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html}{layoutEngine} \cite{base02} \cite{base03}, in exploration of this underlying question. This R package was developed by Dr. Murrell during his own research efforts. 

\vspace{2mm}
\href{https://www.r-project.org}{The R programming language} \cite{base04} has a powerful \href{https://www.stat.auckland.ac.nz/~paul/RG3e/}{graphics system} \cite{base05} but it has several limitations within the scope of Print Quality Graphics. The layoutEngine attempts to provide this functionality with a non-standard approach. It is designed to link R’s graphic system to a modern web browser and thereby tap into the rich and well established technologies of HTML, CSS and JavaScript. 

\vspace{2mm}
The subject research includes the development of a major component of the layoutEngine in order to overcome several limitations of the existing implementations. Two versions of this component were developed to explore different designs to meet the component requirements: (i) the \textbf{RSelenium Backend} and (ii) the \textbf{NodeJS Backend}. Both show improvement over the existing implementations by incorporating a defined Target Feature Set within their functionality. The NodeJS version appears to offer the most promise for future work. 

\vspace{2mm}
The research paper will explain the /layoutEngine approach/ to extending R's graphic system. It will then review the existing solution design and present several key limitations. The paper then steps through the solution design of the RSelenium and NodeJS Backends and present how these implementations improve upon the existing designs. It should be noted the comparisons made between each implementation are qualitative in nature as the primary objective was to explore alternative solutions as opposed to performance enhancements which are easily measured. A review of both newly developed Backends compared to the existing implementations is provided to conclude. 


\subsubsection*{Accompanying Development Content}  

The following GitHub repositories and Docker images were developed by the author as part of this research and are submitted as a practical accompanyment to this report. 

\noindent
*Research Files:*
\begin{itemize}
\item \href{https://github.com/kcullimore/layoutengine-research}{GitHub: Report and Supporting Content} \cite{repo01}
\item \href{https://hub.docker.com/repository/docker/kcull/layoutengine-research}{Docker Image: Reproducible Report} \cite{repo02}
\end{itemize}

\noindent
*RSelenium Backend:*
\begin{itemize}
\item \href{https://github.com/kcullimore/layoutenginerselenium}{GitHub: layoutEngineRSelenium R Package} \cite{repo03}
\end{itemize}

\noindent
*NodeJS Backend:*
\begin{itemize}
\item \href{https://github.com/kcullimore/layoutengineexpress}{GitHub: layoutEngineExpress R Package} \cite{repo04}
\item \href{https://github.com/kcullimore/express-server}{GitHub: NodeJS Backend Server} \cite{repo05}
\item \href{https://hub.docker.com/repository/docker/kcull/layoutengine-express}{Docker Image: NodeJS Backend Server} \cite{repo06}
\end{itemize}

\newpage  
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

* Introduction

The *[[https://www.r-project.org/][R programming language]]* \cite{base04} is a popular open-source statistical analysis tool. The language has many packages that support sophisticated statistical techniques. Many of these rely on graphical output to communicate results. A strong appeal of this programming language is the ease at which its core *graphics system* \cite{base05} generates graphical output that is both accurate and effective at communicating this type of information. 

Few open-source alternatives offer an equivalent set of sophisticated statistical methods married with a flexible and powerful graphics system. The Python programming language is a strong competitor. However, its focus is more as general purpose programming language with fewer specialized statistics packages that generate these types of graphic types with equivalent rigor. 

The number of specialized applications R is used within has grown along with its popularity. One such use-case is the incorporation of the statistical graphic within published articles. While the raw dots and dashes used to generate these graphics is of sufficient digital quality there are several fundamental publishing requirements which are not supported.

* Problem Description

The publishing industry has a long history dating back to the 15^{th} century when movable type printing was first invented. As the industry integrated within digital media it has brought with it a system of long-standing expectations for content. As a result, digital publications often have a myriad of requirements for graphics which are referred to in this report as **print quality graphics**. 

Some of the more important requirements include *(1)* writing system and font specifications, *(2)* document layout and typesetting, *(3)* sophisticated content rendering, and *(4)* control over output resolution and file format.

R users have a powerful tool for generating statistics based graphics but they will struggle to support many of these requirements. Several examples are presented below which show features which are not currently possible with the core graphics system.


\vspace{5mm}
\noindent
*NOTE:* Each of the following examples have been produced with the layoutEngine using a newly developed layoutEngine Backend as part of this research. The code for these examples are found within the Appendix of this report.


#+BEGIN_center 
#+ATTR_LATEX: :width 4in  
[[/project/research/code/examples/ex-1.png]]
\textsf{Example 1: Using Multiple Font Types in the Same Graphical Component}
#+END_center 

#+BEGIN_center 
#+ATTR_LATEX: :width 3.5in  
[[/project/research/code/examples/ex-2.png]]
\textsf{Example 2: Embedded Graphics With Automatically Wrapped Text}
#+END_center 


#+BEGIN_center 
#+ATTR_LATEX: :width 3in  
[[/project/research/code/examples/ex-3.png]]
\textsf{Example 3: Complex Layouts Of Text And Graph Components}
#+END_center 


An existing solution to produce print quality graphics is to modify the R graphical output with external tools such as LaTeX or /Adobe Illustrator/. The user must either be proficient in both environments or have a specialist available to help. 


#+BEGIN_center 
#+ATTR_LATEX: :width 5.5in  
[[/project/research/resources/img/old-system-external.png]]
\textsf{External Applications Used to Produce Print Quality Graphics}
#+END_center 

Another solution would rely on several existing R packages. Such packages offer bits of this functionality ad hoc. The user would remain within the R ecosystem but might need several packages depending on the publishing requirements. This modular feature-set composition is the /standard R approach/ to extend its functionality. 


#+BEGIN_center 
#+ATTR_LATEX: :width 5.5in  
[[/project/research/resources/img/old-system-internal.png]]
\textsf{Standard R Approach to Produce Print Quality Graphics}
#+END_center 


This research explores an alternative approach, referred to as the /layoutEngine approach/, which offers a general purpose solution to generate print quality graphics from within the R ecosystem. This approach is encapsulated by the layoutEngine R package which incorporates web technologies to extend the functionality of the R graphics system. 

The motivation of this approach is based on the understanding that web technologies and modern browsers have long supported the special needs of the publishing industry. As a result, there is much functionality to be gained by leveraging this technology. The layoutEngine intends to create access to a full-suite of industry leading functionality. This hinges on whether it can successfully utilize the browsers graphics system in an easy to use R package with accessible dependencies. 

Please note that this research does not address the relative performance and functionality difference between the /layoutEngine approach/ and the /standard R approach/. Rather, it /first/ explores the efficacy of this /layoutEngine approach/, and /second/, attempts to improve upon the implementation of the existing layoutEngine package to address several existing limitations. 

* The layoutEngine R Package

The intent of the *[[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][layoutEngine]]* \cite{base02} R package is to extend R's graphics system by adopting functionality available in web technologies. Its core functionality is to act as an interface between R and a web browser to provide access to the rich feature set. The package is available to review via the [[https://github.com/pmur002/layoutengine][layoutEngine GitHub repository]] \cite{base03} however it is still in development and not yet available in *[[https://CRAN.r-project.org/][CRAN]]* \cite{base06}. 

** The Standard R Approach

The /standard R approach/ to extend its functionality is paramount to the success of open-source programming languages. Available packages are freely shared within the community which can be loaded into the scope of a R session to gain specific functionality. If a broader feature set is needed then several packages are loaded which acts as a modular system. There are many advantages to this approach and it is a key reason why these languages and user communities have thrived. 

Several *[[https://CRAN.r-project.org/web/packages/available_packages_by_name.html][available CRAN packages]]* \cite{base07} offer functionality which meet specific publishing requirements. Many of these packages are well executed and perform admirably. The /[[https://github.com/wilkelab/ggtext][ggtext]]/ package \cite{base08} enables multiple font types to be specified in the same graphic. The /[[https://github.com/thomasp85/patchwork][patchwork]]/ package \cite{base09} offers a similar functionality specifically for arranging several ggplots with claims of increased simplicity and flexibility. In addition, the base package /[[https://stat.ethz.ch/R-manual/R-devel/package/grid/html/grid.layout.html][grid]]/ \cite{base10} has a \texttt{layout} function which creates a \texttt{Grid} layout object \cite{base11} that enables plots from different systems to be arranged together. Many other packages extend R towards the realm of print quality graphics but no general purpose solution exists at this point in time.  

The standard R approach might eventually succeed in offering a general purpose solution to generate print quality graphics. However, several difficulties exist would first need to be overcome. First, the publishing requirements represent an extensive set of functionality. In addition, the variety of graphical output this must operate with is also large. As a result, the task of coordinating a suite of purpose-built packages that is flexible enough to cover all scenarios would be significant. This is both difficult from both a developer and user perspective due to the large number of package specific syntax to navigate. 

** The layoutEngine Approach

The /layoutEngine approach/ differs with the way it extends the functionality of R. It acts as an interface between the graphics system in R and another technology ecosystem: the web browser. This general purpose solution attempts to adopt from an industry that has a long history supporting publishing requirements so as to avoid reinventing the wheel. 

This approach bypasses the need to build a complex general purpose solution from the ground up and instead employs existing tools. These tools are part of the web-based languages (HTML, CSS and JavaScript) and R packages which can be used generate HTML from R objects. The table below identifies some of these technologies which can be used to generate a print quality graphic.
  
#+BEGIN_CENTER
\sffamily\small
#+attr_latex: :align p{0.25\textwidth}p{0.5\textwidth}
| *Functionality*        | *Technology*                                               |
|------------------------+------------------------------------------------------------|
| Layout and Typesetting | HTML elements styled with CSS Grid or Flexbox              |
| Font Type and Styling  | CSS @font-face with traditional CSS styles                 |
| Text Wrapping          | Standard HTM, CSS shape-outside                            |
| R to HTML Conversion   | xtable, formattable, htmltools, gridSVG, rmarkdown, etc... |
|                        |                                                            |
#+END_CENTER

The simplified diagram below demonstrates how the layoutEngine is used for a general use-case. The process would include the following: 
1. The graphic is first generated as an R object
2. This is converted to HTML where some additional definition could be added
3. The HTML based data is transferred and loaded into a web browser
4. The browser's layout and rendering engine generates the desired graphic in the browser window 
5. A JavaScript function is then executed to separate and calculate the position of each component on the page
6. This data is then sent back to R in CSV format where the layoutEngine will convert it to a R readable graphic object
7. This can then be displayed in the R graphics window or sent directly to an image file


#+BEGIN_center 
#+ATTR_LATEX: :width 5.5in  
[[/project/research/resources/img/layoutEngine-system.png]]
\textsf{Produce Print Quality Graphics Using the layoutEngine}
#+END_center 

*** Benefits

There are several key benefits to the /layoutEngine approach/ that are the motivating drivers of this exploration. 

The most important benefit is that the HTML and CSS languages are well suited to managing attributes of elements *within* the graphic. The intention is to not just drop an R graphic within the middle of some HTML as a "dumb blob" but rather to further enhance its styling and content. It is the mechanism for R users to /programmatically/ control aspects of the graphic in a precise and repeatable manner that is of most interest. 

A second key advantage is that web technologies serve a large economy that has demanded a robust feature set and accessible programming paradigms for several decades. Part of this economy, one of which is the publishing industry, cares greatly about the aforementioned features that fall within Print Quality Graphic. If the approach is successful we can hope to gain the following advantages: 
- Large community of developers that are well versed in the web languages (HTML, CSS and JavaScript)
- Active support and advancement of standards, new features and extension libraries
- Large amount of references and resources for new developers to become proficient quickly
- Sophisticated layout and rendering engines within modern browser which are continually being updated to support the latest web standards

Lastly, there are already several R packages that generate and manipulate HTML and SVG content. The hope is that an R user can take advantage of these packages to help improve the efficiency the can generate the needed HTML to work with the layoutEngine. Some of these packages are Knitr, xtable and htmltools. 

*** Limitations

The /layoutEngine approach/ offers some compelling advances but there are several limitations that should be recognized. 

The first and perhaps the most critical is that R users need to enter HTML based code in the layoutEngine functions. This requires the use of an available R packages to create HTML from their R code. If they want to use anything semi-customized or unique they would be required to generate that directly within HTML syntax. While these web languages are common in the industry it does require the user to either already be proficient in these or willing to learn. 

The complexity of the interface between the R Session and the web browser is substantial. Since the browser has been built for use with the public internet there are several security features to get around. The R session cannot just load a local file into the browser and start using its layout and rendering engines. Instead, a web server is needed to host a web page on the local machine's network thereby serving the page in the manner expected by the browser. This requires several additional technical requirements that add to the complexity of the basic concept. 

Another important limitation is based around the state of the implementation of this layoutEngine R package. Since it is very much in a prototype phase there are several missing features and incompatibilities between the web languages and what is able to be converted back to an R graphic object. As such, there might be some frustration or lack of completion due to these gaps. 

** Solution Design

The layoutEngine solution design is comprised of two components as shown in the figure below. The [[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][layoutEngine]] is configured to interface with one of several available *[[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html#Backends][layoutEngine Backends]]* \cite{base02}. The layoutEngine acts as the interface for the R user while the layoutEngine Backend is the interface between R and the web browser. This solution was chosen as much of the complexity exists in the Backend. This abstracts much of the complexity away from the user and allows various Backend designs to be swapped out with little impact to the main layoutEngine interface.

#+BEGIN_center 
#+ATTR_LATEX: :width 5.5in  
[[/project/research/resources/img/layoutEngine-system-context.png]]
\textsf{layoutEngine Solution Design}
#+END_center 

*** layoutEngine R Package
The layoutEngine is responsible for handling all the web-based data to send to the layoutEngine Backend. It must also take the returned data from the Backend and render this within the R graphics display. A major piece of this involves locating the correct fonts within the host machine to ensure the browser calculations are made using the exact font specifications. 

\noindent  
*Functionality:* 
- Interface for R users to execute commands and configure the Backend
- Handling of web page content (HTML, CSS, Fonts, Assets)
- Call of Backend primary interface
- Handle returned layout calculation
- Rendering of new content within R Graphics Display

\noindent
*Challenges:* 
- Ensuring ease-of-use for R users by tolerating various web-based content types and formats
- Cross-platform access to system fonts
- Support conversion of web-based graphic data to the R graphics display 

*** layoutEngine Backend R Package

The layoutEngine Backend is where much of complexity exists required to interface with a web browser. Since there are many possible ways to implement this functionality it is contained within a separate R package. The main purpose of the Backend is to serve the R graphic to a browser, execute the layout calculation script and return data to the layoutEngine. The Backend contains the primary challenge of the /layoutEngine approach/.
  
\noindent
*Functionality:* 
  - Locate and manage a modern web browser session
  - Send and receive data between a R session and web browser
  - Query and modify the web-page DOM 
  
\noindent
*Challenges:* 
- Variability in Host Machine 
  - Cross-platform system calls for macOS, Windows and Linux
  - System dependencies and installation requirements
- Web Browser Interface
  - Server implementation
  - Bidirectional communication between R and the browser

* layoutEngine Development

The viability of the /layoutEngine approach/ is still being explored. The layoutEngine Backend consists of the majority of its limitations. There are several existing layoutEngine Backends which are summarized in this section. Each has certain benefits and limitations. 

The subject research focuses primarily on developing some alternatives to these existing implementations of layoutEngine Backends. This includes the development of two new layoutEngine Backends which aim to incorporate a *Target Feature Set*. This set was identified as being paramount to the needs of a production ready solution. One of these Backends relies on a *[[https://www.selenium.dev/documentation/en/][Selenium Server]]* \cite{base19} hosted within a [[https://www.docker.com/resources/what-container][Docker container]] \cite{base20}. The second Backend is a custom *[[https://nodejs.org/en/][NodeJS]]* \cite{base21} server also hosted within a Docker container. 

This section outlines the primary requirements for these development efforts including: *(1)* Component Interfaces, *(2)* Minimum Technical Requirements and *(3)* the Target Feature Set. The existing Backends are presented and qualitatively scored against these requirements as a means of comparison of the new development effort. 

** Component Interfaces
*** R User Interface
Development for a layoutEngine Backend requires meeting the interface requirements for the layoutEngine package itself. In the example below, the Backend is specified and then the layoutEngine \texttt{\bfseries grid.html()} function is called with the specified arguments. Since the Backend is isolated, this /R user interface/ remains the same for all Backends. 

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
## Load packages for layoutEngine and Backend and set the Backend
package(layoutEngine)
package(layoutEngineRSelenium)
options(layoutEngine.Backend=RSeleniumEngine)
## Basic example supplying HTML, FONTS, CSS, ASSETS
HTML <- '<div class="content"><h1>This is some simple text</h1></div>'
FONTS <- cssFontFamily("FreeMono")
CSS <- '.content {font-family: FreeMono; border: solid; width: 800px; height: 100px; display: flex; justify-content: right;}'
## Call layoutEngine
png("essential-example.png", width=800, height=100)
grid.html(html=HTML, fonts=FONTS, css=CSS)
dev.off()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
#+BEGIN_center 
#+ATTR_LATEX: :width 4in  
[[/project/research/code/examples/essential-example.png]]
\textsf{layoutEngine Output: "essential-example.png"}
#+END_center 

*** Backend Interface 

The /Backend interface/ is contained within the \texttt{\bfseries engine.R} component of all the Backends. This file specifies a  \texttt{\bfseries Layout} and  \texttt{\bfseries fontFile} function that is used to instantiate a layoutEngine Backend Engine object using the \texttt{\bfseries layoutEngine::makeEngine()} function. The requirements and flexibility of this object is documented within the \texttt{\bfseries makeEngine()} [[https://github.com/pmur002/layoutengine/blob/master/man/makeEngine.Rd][help page]] \cite{base22}. 

The \texttt{\bfseries layout} argument is the minimum requirement needed to instantiate a Backend object. This function takes the supplied HTML based data and then generates a layout of the page with a browser layout engine. This layout engine is expected to be provided within a typical browser, however, as seen with the PhantomJS and CSS-Box Backend solutions, such layout engines can also be supplied via atypical implementations. 

Once the web-page layout has been performed within the browser (or equivalent), the next requirement is the layout is captured within a R readable form. This is a critical piece of the layoutEngine functionality. For this research, the script that executes this step was taken from the [[https://github.com/pmur002/layoutenginedom/blob/master/inst/JS/layout.js][DOM Backend]]. In general, this JavaScript function updates the web-page DOM to isolate all text characters within a single bounding box. Once each element has its bounding box, the locations and content for each box is exported from the DOM and transformed into CSV format. 

The layout CSV is then transferred back to the layoutEngine primary package where it redraws the graphic within the R graphic display. For all of this to work well, each component must be defined and tracked through this entire process. Of special concern is that of the specified fonts. Since all fonts vary dramatically in their shapes and sizes, the actual font files must be identified on the host machine and then transferred to the browser where they are incorporated into the web-page using the \texttt{\bfseries @font-face} CSS feature.

The layoutEngine Backend has much flexibility in the way it can be implemented provided this core functionality is provided. In general, these minimum requirements of the \texttt{\bfseries layout} function include: 
1. Start up a server used to host the web-page
2. Find the specified font files within the host system 
3. Copy asset files to the server (fonts, images, embedded HTML, etc) 
4. Open a web browser 
6. Serve the web-page
7. Execute the layout calculation script within the browser
8. Send the returned CSV back to the layoutEngine

** Minimum Technical Requirements

The layoutEngine Backend must meet several key technical requirements to adequately perform the necessary functions as outline in the previous section. These requirements can be addressed in a variety of ways as is evident in comparing the existing Backends later in this section. These Minimum Technical Requirements have been categorized as-follows to improve the ease of comparison. 

\noindent
*Locally Hosted Server:*

- Provides a mechanism to communicate with a web browser and access the full capability of the layout and rendering engines
- Supports live refresh of the web page upon when changes are made is necessary to give the R user a similar experience they're used to with the R graphics display. This prevents the user from having to push a 'refresh' command to see the changes. 


\noindent
*Browser Integration:*

- Use of a modern web browser to ensure ability to utilize the best features of HTML, CSS and JavaScript as they become available
- Interactions with browser can be implemented in a traditional protocol such as HTPP or Web Sockets. It can also be implemented with a purpose built API such as Selenium or Google's Puppeteer \cite{base23}.
- Maintain a single web browser instance for each layoutEngine call to prevent multiple browsers from sending layout calculations back to R

\noindent
*Bidirectional Communication:*

- The Backend must support a browser compatible communication protocol
- Data must be transferred between R and the browser in both directions. The Backend must first send the web-based data to the browser and then on the completion of a layout calculation, send a text-based message back to R. 
- Data can be of the following types
  - To the browser
    - Asset files such as images and font files to the hosted webpage from the host machine
    - DOM components from the R layoutEngine call
    - Call to execute the layout calculation script
  - From the browser
    - Either request or accept the layout calculation CSV as a file or in memory data

\noindent
*System Interface:*

- A key piece requirement of the layoutEngine is that it can access the host machine's system fonts. This requires the layoutEngine Backend to execute system calls to locate and retrieve such font files. 
- Any virtual machine based solution must be able to access the graphics system of the host machine to run a browser in a traditional manner (i.e. not in headless mode)

** Target Feature Set

A Target Feature Set is defined below to include features that are identified as being paramount to the needs of a production ready solution. These features limit the barrier to successfully utilizing the layoutEngine approach for a general R user. If these can't be met, the approach would be too cumbersome for most users to adopt. 

\noindent
*Cross Platform:*

An emphasis is placed on new layoutEngine Backends to support all three major platforms (Linux, MacOS and Windows). While the existing Backends prove the viability of the layoutEngine functionality it is deemed absolutely necessary for the package to be easily used on all platforms. There is little chance the package would be found useful across the industry if it were only available on Linux platforms. A primary reason for this being that a majority of users are on either Windows or MacOS. The challenge is mainly based on the installation dependencies and host graphics device usage. 

\noindent
*Simple Dependencies:*

Secondary to cross platform support, the Backend must also have relatively simple installation requirements for all platforms. The intention here is to improve the user experience by making the installation as easy as possible. In addition, with fewer requirements there is less opportunities for future incompatibilities to arise. 
- Few dependencies on other development teams for critical components that might either create bugs or prevent the support of the latest web technologies
- As simple implementation as possible which: 
  - Reduces the weight of the installed package
  - Enable easy future support or extensions by others
  - Provide as few opportunities for issues, bugs, etc and improve the maintainability and comprehension by other contributors to the project

\noindent
*Industry Support:*

It is critical that any technologies that are incorporated into the layoutEngine Backend have development support into the future. The more common and widely used such technologies are the less likely there will be technical issues as other parts of the ecosystem advance. 

\noindent
*Modern Web Standards:*

It is preferred the Backend design is able to support modern web standards for /Web Design and Applications/ as defined by [[https://www.w3.org/standards/webdesign/][W3C]] \cite{base18}. If the latest and greatest standards are not fully supported then an acceptable lag of 1 to 2 years from the most recent release. This feature should be considered as relatively important as many users will be turned off from too much lag between what is seen as industry standard versus cutting edge. 

\noindent
*Visual Feedback:*

It should be considered valuable to have access to a live browser for several reasons. Although headless browsers might be considered more easily implemented there is significant value in being able to see the graphical output within the browser. For example, the user can see quickly identify any discrepancies between in supported web technologies between the browser and R graphics display.

** Existing Backend Designs
   
There are three layoutEngine Backends available for use with the layoutEngine at the time of this research. These Backends successfully demonstrate the viability of this approach. 

*** DOM Backend

The DOM Backend \cite{base12} is fully contained within R and employs only R packages to gain the minimum technical requirements. 

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Benefits}
\normalfont\normalsize

- Built entirely within the R ecosystem
- Access to latest web browser and therefore latest HTML, CSS and JS specs

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Limitations}
\normalfont\normalsize

- Default browser opens a tab with a newly supplied random port on every call
- The API is built with one-to-one wrappers of the DOM scripting methods which creates a tightly coupled connection which might miss some functionality if not purposefully captured
- The supplied API is incomplete and does not capture all HTML and CSS functionalities

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Minimum Technical Requirements}
\normalfont\normalsize

- Locally Hosted Server:
  - The R httpuv package \cite{base13} is used to create a static web server for web page hosting. 
- Browser Integration:
  - Once the server has been initiated and the layoutEngine grid.html() function has been called, the default browser on the host machine is automatically launched and navigated to the hosted page at http://localhost:port-number. The port number is randomly generated for each layoutEngine grid.html() function call to reduce the likelihood of conflicting port assignment. 
- Bidirectional Communication:
  - The R httpuv package is also used to create a Web Socket server which creates a bidirectional communication protocol with the local default browser. 

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Ratings for Target Feature Set }
\normalfont\normalsize

- Cross Platform: *Medium*
  - The DOM Backend has only ever been used and tested on a Linux machine. It uses specific Linux system calls of which several would fail in other operating systems. The rating is set at Medium since much of this could be re-engineered to work on other platforms.  
- Simple Dependencies: *Medium*
  - The primary dependencies for the DOM Backend consist of the Linux OS and several R packages. Outside of the OS requirement the dependencies are relatively simple for an R User. 
- Industry Support: *Low*
  - The DOM Backend is custom built on very primitive server based methods provided by the httpuv R package. While the httpuv package is actively maintained by members of the RStudio team the DOM package itself contains much of the necessary functionality that would need to be extended and maintained if this Backend was used as a production ready design. 
- Modern Web Standards: *Medium*
  - The DOM Backend relies on the users local browser which is the best case scenerio for ensuring the latest web technology standards are available for use. However, the implementation of the DOM Backend uses R wrappers around JavaScript DOM scripting methods. As such, these would have to be maintained and extended to accommodate any significant changes in web standards. 
- Visual Feedback: *High*
  - The Backend uses the local browser with full visibility of the web page content. 

*** PhantomJS & CSSBox Backends

The PhantomJS and CSSBox Backends have been combined here since they are very similar in their implementations as it pertains to the following requirements. Both utilize non-browser layout engines. The PhantomJS Backend \cite{base14} uses the PhantomJS \cite{base15} scriptable headless browser to interface directly with the web page DOM. The CSSBox Backend \cite{base16} uses the Java based CSSBox \cite{base17} headless browser to interface directly with the web page DOM. 


\vspace{5mm}
\noindent
\sffamily\bfseries\large{Benefits}
\normalfont\normalsize

- Implementations have single dependencies on their respective HTML layout engine technology
- Headless browser API greatly simplifies the requirements to host a web page and communicate with a typical browser

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Limitations}
\normalfont\normalsize

- No option for visual browser use
- Both HTML layout engine technologies suffer from development support issues 
- Based on older layout engines so behind on latest web standards

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Minimum Technical Requirements}
\normalfont\normalsize

- Locally Hosted Server:
  - Both Backends have standalone layout engines that don't necessitate the requirement to access the page from a traditional server. As such, neither require a server to be running which is a significant benefit to both of these designs. 
- Browser Integration:
  - The "browser" in these cases refers only to the layout engine component of each of these headless browsers. Again, this approach simplifies the need to integrate with an open browser R would only need to access each of these systems that are running on the host machine. The requirement instead is that the R user would have to have either system installed and configured appropriately on their host machine.
- Bidirectional Communication:
  - Both have their own API that can be access programmatically from R. Each API implements the DOM scripting methods that allows access to the DOM to query and edit. 

\vspace{5mm}
\noindent
\sffamily\bfseries\large{Ratings for Target Feature Set }
\normalfont\normalsize

- Cross Platform: *Medium*
  - Similar to the DOM Backend, both of these Backends have only ever been used and tested on a Linux machine. Both use specific Linux system calls of which several would fail in other operating systems. Both the PhantomJS and CSSBox can be configured to run on all major operating systems so they should not pose any limitation to this target feature. The rating is set at Medium since much of this could be re-engineered to work on other platforms.  
- Simple Dependencies: *Low*
  - Both Backends require the installation and configuration of these independently maintained tools. CSSBox is especially difficult as it relies on a compatible Java JDK to be available on the host machine. This dependency is quite limiting for a general purpose tool. 
- Industry Support: *Low*
  - The PhantomJS developer team have already declared the tool is no longer supported. The CSSBox is still being maintained however the last version update occurred in November of 2019. 
- Modern Web Standards: *Low*
  - Since both tools lack adequate support to keep their API's and layout engines compatible with the latest web standards. 
- Visual Feedback: *Low*
  - Neither support visual feedback as they're both headless browsers and therefore can't provide a live view of the browser screen. 
 
*** Qualitative Comparison

The following list outlines how each layoutEngine Backend was ranked against the target feature set: 
#+BEGIN_CENTER
\sffamily\small
#+attr_latex: :align p{0.3\textwidth}p{0.15\textwidth}p{0.15\textwidth}p{0.15\textwidth}
| *Limitation*         | *DOM* | *PhantomJS* | *CSSBox* |
|----------------------+-------+-------------+----------|
| Cross Platform       | Med   | Med         | Med      |
| Simple Dependencies  | Med   | Low         | Low      |
| Industry Support     | Low   | Low         | Low      |
| Modern Web Standards | Med   | Low         | Low      |
| Visual Feedback      | High  | Low         | Low      |
#+END_CENTER
\sffamily\footnotesize
Key:
- *Cross Platform:* Compatibility with all major operating systems (Linux, MacOS and Windows)
- *Simple Dependencies:* Simple installation with few dependencies that are consistent across platforms
- *Industry Support:* Robust industry support of any incorporated tools, technologies and standards 
- *Modern Web Standards:*  Support for modern web standards including HTML, CSS and JavaScript             
- *Visual Feedback:* Ability to view graphics within live browser

\small
\normalfont
\newpage
* RSelenium Backend

The RSelenium Backend development effort is captured entirely within the *[[https://github.com/kcullimore/layoutenginerselenium][layoutEngineRSelenium R Package]]* \cite{repo03}. It has been developed with the use of two preexisting technologies. The first incorporated technology is the *[[https://www.selenium.dev/][Selenium WebDriver]]* \cite{base19} which is a robust browser automation tool. The second is the *[[https://cran.r-project.org/web/packages/RSelenium/index.html][RSelenium R package]]* \cite{base24} which provides an interface to the Selenium WebDriver from within R. The Selenium WebDriver is used from supported Docker images which they host on their *[[https://hub.docker.com/u/selenium][Selenium Docker Hub]]* site \cite{base25}.

This section first presents the solution design of the layoutEngine Backend using Selenium. This is then followed by an evaluation of the design based on the Minimum Technical Requirements and Target Feature Set defined earlier in the report. 

The primary interest in using Selenium is that is a powerful and popular tool that offers a more robust platform to control a web browser. The fact the RSelenium package allowed for easy use of this tool off-the-shelf further increased its appeal. While the benefits for this solution design are significant there are also several limitations (or downsides) to its use. The motivation behind the RSelenium Backend package includes the following: 
- Selenium Server 
  - Robust solution that offers a large set of ways to control a browser
  - Strong technical community with evidence of future support due to wide industry use
  - Support of docker containers
  - Docker container includes controlled web browser types which improves consistency
  - Direct access to the webpage DOM via the Selenium server commands 
- RSelenium
  - R interface to Selenium Server already exists
  - Tests shows relatively simple controls

** Solution Design
 
#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/project/research/resources/img/rselenium-backend.png]]
\textsf{RSelenium Backend Design}
#+END_center 

*** Primary Components
- RSelenium Backend 
  - The RSelenium Backend is comprised of the components outlined in the diagram above. All of these components must be available and configured correctly on the host machine for the Backend to be operational. 
  - The R user must have Docker installed on their host machine and one of the Selenium Docker images available to start a container from. The user must also have the layoutEngineRSelenium R package installed in their R session. 
- [[https://github.com/kcullimore/layoutenginerselenium][layoutEngineRSelenium R Package]] \cite{repo03}
  - This R packages was the principal development effort for this Backend design. It contains all of the necessary function calls to run the Selenium Docker container. It then uses the RSelenium R package to communicate with the Selenium server via its API. Once the container is running, a browser is launch from within the container and the Backend can then gain access to the web page DOM via the Selenium API. 
- [[https://cran.r-project.org/web/packages/RSelenium/index.html][RSelenium R package]] \cite{base24}
  - The RSelenium R package provides access to the Selenium API from within R.
- [[https://hub.docker.com/u/selenium][Selenium Docker container]] \cite{base25}.
  - A Selenium Docker container is needed to run the RSelenium Backend. The container is a fully functional Selenium server and WebDriver combined with a single browser type. The R user can choose to use either a Chromium, FireFox or Opera browser by selecting the correct image.

*** Function Call Relationships

**** RSelenium Backend Arguments

\ttfamily   
- - url='127.0.0.1' /rightarrow local URL to serve the page
- - portRS=4444 /rightarrow Docker container Selenium server port
- - portClient=4444 /rightarrow Docker container host machine port
- - network='bridge' /rightarrow Docker container network type
- - shm\textunderscore size='1g' /rightarrow Docker container shm memory to allocate
- - browser\textunderscore type='firefox' /rightarrow Selenium browser type to use {Chrome, Firefox, Opera}
- - headless=FALSE /rightarrow If the browser should be run in headless mode
- - image\textunderscore request=NULL /rightarrow User supplied Selenium image to pull
- - fresh\textunderscore pull=FALSE /rightarrow Should Docker pull the latest image version from Docker Hub

\normalfont
**** layoutEngineRSelenium Backend Setup

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
package(layoutEngine)
package(layoutEngineRSelenium)
options(layoutEngine.Backend=RSeleniumEngine)
## Firefox Selenium docker image
firefox_build <- "3.141.59-20200525"
firefox_image <- paste0("selenium/standalone-firefox-debug:", firefox_build)
## Chrome Selenium docker image
# chrome_build <- "3.141.59-20200525"
# chrome_image <- paste0("selenium/standalone-chrome-debug:", chrome_build)
## Select which image to test
test <- list(name="firefox", image=firefox_image)
# test <- list(name="chrome", image=chrome_image)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Docker Container Component


The Selenium Docker container call \texttt{\bfseries dockerContainer()} will start up the Selenium Docker container per the argument settings. It also has methods to get status and stop the container. 

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
## User settings for component test
settings <- list(url="127.0.0.1", portRS=4444, portClient="4444", network="bridge", shm_size="1g",                      
                 browser_type=test$name, headless=FALSE, image_request=test$image, fresh_pull=FALSE)
## Setup RSelenium Backend Docker container based on user settings
container <- dockerContainer(settings)
## Run the RSelenium docker container 
container$run()
## Get RSelenium docker container status
container$getInfo()
## Stop and delete the RSelenium Docker container 
container$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Selenium Server Component
  
The Selenium server call \texttt{\bfseries rSServer()} will start up the Selenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 
  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
## Setup RSelenium Backend Selenium server hosted on the docker container
RSServer <- rSServer(settings)
## Get Selenium server status
RSServer$getStatus()
## Open a browser instance hosted within the Docker container
RSServer$open()
## Close RSelenium Backend Selenium server hosted on the docker container
RSServer$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Selenium Browser Session Component
  
The RSelenium Server call \texttt{\bfseries rSServer()} will start up the RSelenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 
  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
## The outer most component starts all encapusalated components
RSSession <- rSSSession(url="127.0.0.1", portRS=4444, portClient="4444", network="bridge", shm_size="1g",
                        browser_type=test$name, headless=FALSE, image_request=test$image, fresh_pull=FALSE)
## Open a browser instance hosted on a Selenium server within the Docker container
RSSession$open()
## Get status of all the components
RSSession$getStatus()
## Close all components (browser session, server and Docker container)
RSSession$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
\newpage
** Solution Evaluation
*** Benefits
The RSelenium Backend performs quite well when working properly. 
- The use of the Selenium server and browser session made it easy to ensure only a single browser session was used for each R layoutEngine call. 
- The communication protocol used to control the Selenium browser's DOM was abstracted away from our development efforts. Since the Selenium server's primary functionality is offering tight controls of a browser we were able to take full advantage of this. This meant that JavaScript DOM scripting methods can be directly applied to modify its content without the need for worrying about using a communication protocol such at HTTP or a WebSocket. 
- Since we can directly modify the contents of the webpage DOM via the Selenium server controls we see live updates in the browser without having to refresh the page. This both improves the user feedback of the using the browser as a debugging device and adds the ability to execute the layout calculation script immediately upon the DOM update. 
- Stand alone server seperate from R

*** Limitations

Some downsides of the RSelenium Backend include the following: 
- Scheduling the start-up of the container, Selenium Server and then the web browser session created some difficulties
- Time required to open the full stack was near 5-10 seconds
- Opening the browser application hosted within the docker container in full mode (i.e. no headless) poses difficulties for Windows and MacOS due to the sharing of the host graphics system. It can be finicky to get this working on all host machines easily. 
- The browser version is controlled by the Selenium development team which must be supported via one of their docker images. This creates a dependency on this external development team to ensure the latest browsers (and therefore latest web specifications) can be maintained. 
- It was found that a latest docker image created a bug with the RSelenium R package that was no longer up to date. Dependencies on both the Selenium docker iamges and RSelenium R Package poses some risk of future bugs or lack of support for the latest features. 

*** Minimum Technical Requirements

- Locally Hosted Server: 
  - The Selenium WedDriver has its own integrated server which provides a large set of functionalities. It has an API which can directly modify the contents of the DOM via [[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction][JavaScript DOM scripting methods]] \cite{base26}. This API negates the need to implement a stand-alone server to serve any content to a URL since the layoutEngine can insert content directly into the \texttt{body} of the DOM. 
- Browser Integration:
  - The Selenium Docker images come with customized full-featured browsers of the major types: Chromium, Firefox, Opera. In the Backend design, the browser and the Selenium server are run from within the Docker container. This implementation requires the Docker container has access to the host graphics system which can create some dependency and security issues. This is needed so the browser can open on the host machine as a fully operational application. Unfortunately, there isn't strong support for this from Docker since it is not a primary use-case. 
- Bidirectional Communication:
  - The primary strength of this Backend design is the integrated browser controller which allows direct access to the DOM from R. As such, the Backend can perform all types of DOM manipulations such as adding content, executing a JavaScript function and retrieving content. These are the primary communication requirements for the layoutEngine. 

*** Ratings for Target Feature Set

- Cross Platform: *Medium*
  - The primary installation requirements is Docker. This is available on all major operating systems. The Backend solution would require the R users to have Docker installed and the required Selenium Docker images downloaded. This is considered a good solution to provide Cross Platform support however the necessity to run the containerized browser via the host graphics system introduces additional complexity to support all operating systems. At this point, the Backend was successfully run on each OS however there were many difficulties encountered along the way which would indicate that developing a robust solution would be complex. 
- Simple Dependencies: *High*
  - As mentioned in the Cross Platform evaluation, the dependencies for this Backend are limited to Docker. This is a good solution to what could otherwise be a very complex installation process. The Selenium team explicitly moved to a Docker containerized solution to reduce the burden of installing and configuring the Selenium WebDriver directly on the host machine. The additional installation requirement is the RSelenium R package which is easily installed from CRAN. 
- Industry Support: *Medium*
  - In general, the support for Selenium is very good with updates to their Docker images occurring regularly. The reduction in score was due to the fact the RSelenium R package has to stay in sync with the Selenium updates. It was found that a newly updated Selenium Docker image was incompatible with the RSelenium package which required specifying an older image version. This added complexity and lack of dedicated support for the RSelenium package would pose significant difficulties for a production ready version of the Backend.
- Modern Web Standards: *Medium*
  - In general, the Selenium browsers are kept up to date with the latest released browsers. They are usually only a couple of versions behind the latest available. The deduction comes due to the out-of-sync scenario identified above where only older Selenium images are able to work. This would mean that some of the latest web standards might not be supported. 
- Visual Feedback: *High*
  - The Selenium browser is a fully featured browser so there is visual display of the content which is updated live upon any changes to the DOM. 

** Summary


In general, the RSelenium Backend offers a simple way of controlling a browser. However, there are several issues that this approach presents to future development. As a result, it does not seem to be a robust solution to continue development with. 

\newpage
* NodeJS Backend
  
The NodeJS Backend development is captured within two components: (i) the *[[https://github.com/kcullimore/layoutengineexpress][layoutEngineExpress R Package]]* \cite{repo04} and (ii) a custom built *[[https://hub.docker.com/repository/docker/kcull/layoutengine-express][NodeJS Backend Server Docker image]]* \cite{repo06}. 

This section first presents the solution design of the layoutEngine Backend using NodeJS. This is then followed by an evaluation of the design based on the Minimum Technical Requirements and Target Feature Set defined earlier in the report. 

The primary interest in using a NodeJS based Backend was due to the flexibility in which it can be customized to this specific application. The Backend could be built to reside in a number of different locations including a cloud or external server. It could incorporate complex logic and functionality to execute helpful transformations on the server on each side of the data transmission between R and the browser. The motivation behind the NodeJS Backend package includes the following:
- Building the server from scratch would result in very light-weight package
- Easily customize the functionality of it to suit the layoutEngine
- NodeJS is a very popular language with a large community and strong support into the future
- Several Node packages/packages can be used to take advantage of
- Ability to stay at the very fore-front of web language support since we're in control of all depencies
- Few risky dependencies (i.e. RSelenium and Selenium images)
- Easily work within Docker image for support multiple OS types via communication protocol such as WebSocket or HTTP API
- Can extend functionality of the Backend service in an endless variety

** Solution Design

#+BEGIN_center 
#+ATTR_LATEX: :width 6.5in  
[[/project/research/resources/img/nodejs-backend.png]]
\textsf{NodeJS Backend Design}
#+END_center 

*** Primary Components 
- NodeJS Backend 
  - The NodeJS Backend is comprised of the components outlined in the diagram above. All of these components must be available and configured correctly on the host machine for the Backend to be operational. 
  - The R user must have Docker installed on their host machine and the NodeJS Backend Server Docker image available to start a container from. The user must also have the layoutEngineExpress R package installed in their R session. 
- [[https://github.com/kcullimore/layoutengineexpress][layoutEngineExpress R package]] \cite{repo04}
  - This R packages was one of the principal development efforts for this Backend design. It contains all of the necessary function calls to run the NodeJS Backend Server Docker container. It then uses a Web Socket connection to communicate with the NodeJS server via a custom API. Once the container is running, the R user must manually launch their browser and navigate to the correct URL of the form http://localhost:port. Once the browser has established its own client connection to the NodeJS server the bidirectional communication connection is established between the R session and the browser. The Backend can then send web page content to the browser where it will automatically calculate the layout and export the correct data to send back to the R session. 
-  [[https://hub.docker.com/repository/docker/kcull/layoutengine-express][NodeJS Backend Server Docker container]] \cite{repo06}
  - The NodeJS Docker container has a custom built [[https://github.com/kcullimore/express-server][NodeJS server]] \cite{repo05} that has been developed with the use of three preexisting JavaScript projects. The [[https://webpack.js.org/configuration/dev-server/][webpack DevServer]] \cite{base27} is used as a local server environment that supports live reload of the browser. The [[https://expressjs.com/][Express Server]] \cite{base28} is used as a lightweight web server that is easy to customize. The [[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API][WebSocket API]] \cite{base29} is used to support the bidirectional communication protocol between R and the web browser. The Docker container is designed to operate as a server for local hosting of a web page which the layoutEngine can communicate with.

*** Function Call Relationships

**** NodeJS Backend Arguments

\ttfamily   
- - url='127.0.0.1' /rightarrow local URL to serve the page
- - portServer=4444, /rightarrow Docker container Selenium server port
- - portClient=4444 /rightarrow Docker container host machine port
- - network='bridge' /rightarrow Docker container network type
- - fresh\textunderscore pull=FALSE /rightarrow Should Docker pull the latest image version from Docker Hub

\normalfont
**** layoutEngineExpress Backend Setup

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
package(layoutEngine)
package(layoutEngineExpress) 
options(layoutEngine.Backend=ExpressEngine)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Docker Container Component

The Selenium Docker container call \texttt{\bfseries dockerContainer()} will start up the Selenium Docker container per the argument settings. It also has methods to get status and stop the container. 

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## User settings for component test
settings <- list(url="0.0.0.0", portServer=8080, portClient=8080,
                 network="host", fresh_pull=FALSE)
## Setup Express Backend Docker container based on user settings
container <- dockerContainer(settings)
## Run the RSelenium docker container 
container$run()
## Get Express docker container status
container$getInfo()
## Stop and delete the Express Docker container 
container$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Express Server Component
  
The Selenium server call \texttt{\bfseries rSServer()} will start up the Selenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 
  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## Setup Express Backend WebSocket server hosted on the docker container
webSocket <- webSocket(settings)
## Get WebSocket server status
webSocket$getStatus()
## Get WebSocket connection status
webSocket$ws$readyState()
## Close Express Backend WebSocket server hosted on the docker container
webSocket$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
**** Express Browser Session Component
  
The RSelenium Server call \texttt{\bfseries rSServer()} will start up the RSelenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 
  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: layoutEngine-interface
#+BEGIN_SRC R :exports code
## The outer most component starts all encapusalated components
WSSession <- WSSession(url="0.0.0.0", portServer=8080, portClient="8080",
                       network="host", fresh_pull=FALSE)
## Open a browser instance hosted on a Selenium server within the Docker container
WSSession$open()
## Get status of all the components
WSSession$getStatus()
## Close all components (browser session, server and Docker container)
WSSession$close()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
\newpage
** Solution Evaluation
*** Benefits
The NodeJS Backend has the following benefits:  
- Ability to design server side functionality to extend the usefulness and robustness of the solution
  - Transformations or formatting can be performed on the server before sending back to R
  - Very tight compatibiity between a Node server and the browser 
- Live reload still exists via WebPack dev server
- Lightweight dependencies 
- Stand alone server separate from R
- Server could reside external to the host if there were ever a need or use-case for

*** Limitations
Some downsides of the NodeJS Backend include the following: 
- Have to implement communication protocol
- Managing multiple browser and/or open tabs needs managing
- Performance hit to stand-up docker container and node server
- Unforeseen issues due to new design with little testing 

*** Minimum Technical Requirements

- Locally Hosted Server:
  - The NodeJS Backend uses a well designed development server to host a web page on the host machine. The server implementation is actually two server implementations that are configured operate together. The webpack development server is used to provide a robust auto reloading of the web page when any changes are detected. The Express serve is used to provide a flexible platform to customize the server with a variety of functionality. This extended functionality is the addition of a purpose built WebSocket connection. 
- Browser Integration:
  - The current design relies on the R user to navigate to the correct URL (http://localhost:port-number) via their locally installed browser. This provides the flexibility to use any standard web browser. However, it is important to manage the active connections between a R session and a single browser tab. For example, if a user was to open a Firefox and Chrome browser at the same time and navigate to this URL the R session must be explicit in receiving the returning layout calculations from the expected browser. 
- Bidirectional Communication:
  - The communication between the R session and the browser is supplied by a simple Web Socket API. The logic of this functionality is split between the server and Backend implementations. The server WS definition manages the connections to ensure messages are routed to the correct clients. The Backend client sends HTML based data to the server when the \texttt{grid.html()} function is called via a stringified \texttt{JSON} object. The browser client (i) accepts this HTML based data, (ii) loads in into the \texttt{body} of the web page DOM, (iii) executes the layout JavaScript function and (iv) accesses the results and sends it back to the Backend client as a CSV within a stringified \texttt{JSON} object. 
  
*** Ratings for Target Feature Set

- Cross Platform: *High*
  - The NodeJS Backend was purposefully designed to be easily used on all major operating systems. 
- Simple Dependencies: *High*
  - The Backend requires only Docker and the Backend's Docker image to be available on the host system. All the additional dependencies are installed in the Docker container thereby making the installation relatively straightforward. 
- Industry Support: *Medium*
  - All underlying technologies and projects used within the NodeJS Backend are extremely well supported with strong community of developers and applications. There should not be any lack of support and ongoing development for any of these in the foreseeable future. The primary reason for the reduction in score is the fact this Backend implementation is purpose built for the layoutEngine. As such, it would be up to the maintainer of this Backend to ensure ongoing compatibility with any dependencies. 
- Modern Web Standards: *High*
  - The R user has access to the latest Web Standards by having the freedom to use the browser of their choice. This is the optimal arrangement. 
- Visual Feedback: *High*
  - The local browser can of course offer live visual feedback of the content. 

** Summary

The NodeJS Backend offers a flexible platform to customize and extend the functionality of the layoutEngine Backend. The overall design could be implemented in another server technology however NodeJS seems like a reasonable choice given its growing popularity and reasonable learning curve. The flip side of the coin to this added flexibility is the associated development costs to build a production ready version and keep it maintained into the future. 

\newpage
* Conclusion 

This research explained the /layoutEngine approach/ to extending R's graphic system. It reviewed existing solution design and presented several key limitations. Two newly developed solution designs of the layoutEngine Backend components, the RSelenium and NodeJS Backend, were introduced. They were then evaluated against the same requirements as the existing Backend designs. 

** Comparisons 

Both newly developed Backends demonstrated some key advances in meeting the Target Feature Set while also meeting the Minimum Technical Requirements. These results have been collated into a single table below: 

#+BEGIN_CENTER
\sffamily\small
#+attr_latex: :align p{0.25\textwidth}p{0.12\textwidth}p{0.12\textwidth}p{0.12\textwidth}p{0.12\textwidth}p{0.12\textwidth}
| *Limitation*         | *DOM* | *PhantomJS* | *CSSBox* | *RSelenium* | *NodeJS* |
|----------------------+-------+-------------+----------+-------------+----------|
| Cross Platform       | Med   | Med         | Med      | Med         | High     |
| Simple Dependencies  | Med   | Low         | Low      | High        | High     |
| Industry Support     | Low   | Low         | Low      | Med         | Med      |
| Modern Web Standards | Med   | Low         | Low      | Med         | High     |
| Visual Feedback      | High  | Low         | Low      | High        | High     |
#+END_CENTER
\sffamily\footnotesize
Key:
- *Cross Platform:* Compatibility with all major operating systems (Linux, MacOS and Windows)
- *Simple Dependencies:* Simple installation with few dependencies that are consistent across platforms
- *Industry Support:* Robust industry support of any incorporated tools, technologies and standards 
- *Modern Web Standards:*  Support for modern web standards including HTML, CSS and JavaScript             
- *Visual Feedback:* Ability to view graphics within live browser

\small
\normalfont
\vspace{5mm}
The NodeJS Backend scored the highest across the Target Feature Set. This is primarily due to the fact it was purpose built to meet the development requirements. This is in contrast to the RSelenium Backend which utilized an off-the-shelf technology, a Selenium WebDriver, which required had to be developed around. The single feature the NodeJS Backend didn't get a high rating was the requirement that this Backend design would require a development team to build and maintain the supporting server implementation. This is an understandable trade-off. 

** Future Work

The /layoutEngine approach/ to extending the R graphic system by tapping into an existing rich ecosystem is an intriguing proposition. If the solution design could be developed to behave in a more robust and general purpose manner the payoff would be substantial. The following items would most likely need addressing before a production ready version of the layoutEngine could be built.  
- layoutEngine:
  - A R user interface that more easily accepts standard R graphical output
  - Support for additional HTML/CSS features to add greater value to the extended functionality 
- layoutEngine Backend: 
  - Needs to meets the Minimum Technical Requirements and Target Feature Set covered in this report 
  - Needs to be a production ready solution that can handle being used in a wide range of scenarios




\newpage
\appendix
\addappheadtotoc

* References

  
\begin{thebibliography}{bib}

\bibitem{base01} 
Dr. Paul Murrell's of The University of Auckland, Department Web Page.
<https://www.stat.auckland.ac.nz/people/pmur002>

\bibitem{base02}
Murrell, P. (2018). "Rendering HTML Content in R Graphics" Technical Report 2018-13, Department of Statistics, The University of Auckland.
<https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html>

\bibitem{base03}
The layoutEngine R Package, GitHub Repository.
<https://github.com/pmur002/layoutengine>

\bibitem{base04}
The R Project for Statistical Computing, Home Page.
<https://www.r-project.org/>

\bibitem{base05}
Murrell, P. "R Graphics Third Edition" November 2018, Department of Statistics, The University of Auckland.
<https://www.stat.auckland.ac.nz/~paul/RGraphics/chapter1.pdf>

\bibitem{repo01}
Research Files, GitHub Repository.  
<https://github.com/kcullimore/layoutengine-research>

\bibitem{repo02}
Research Files - Docker Container.  
<https://hub.docker.com/repository/docker/kcull/layoutengine-research>

\bibitem{repo03}
RSelenium Backend, layoutEngineRSelenium R Package, GitHub Repository.  
<https://github.com/kcullimore/layoutenginerselenium>

\bibitem{repo04}
NodeJS Backend, layoutEngineExpress R Package, GitHub Repository.  
<https://github.com/kcullimore/layoutengineexpress>

\bibitem{repo05}
NodeJS Backend, Server Code, GitHub Respository.
<https://github.com/kcullimore/express-server>

\bibitem{repo06}
NodeJS Backend, Server Docker Container.
<https://hub.docker.com/repository/docker/kcull/layoutengine-express>

\bibitem{base06}
CRAN, The Comprehensive R Archive Network, Home Web Page.
<https://cran.r-project.org/>

\bibitem{base07}
CRAN, Available CRAN Packages By Name, Web Page.
<https://cran.r-project.org/web/packages/available\textunderscorepackages\textunderscoreby\textunderscorename.html>

\bibitem{base08}
ggtext, R Package.
<https://github.com/wilkelab/ggtext>

\bibitem{base09}
patchwork, R Package.
<https://github.com/thomasp85/patchwork>
<https://cloud.r-project.org/web/packages/patchwork/index.html>

\bibitem{base10}
grid.layout function within Base R.
<https://stat.ethz.ch/R-manual/R-devel/package/grid/html/grid.layout.html>

\bibitem{base11}
Murrell, P. R. (1999). Layouts: A Mechanism for Arranging Plots on a Page. Journal of Computational and Graphical Statistics, 8, 121–134. doi: 10.2307/1390924. 

\bibitem{base12}
layoutEngineDOM GitHub Repository.
<https://github.com/pmur002/layoutenginedom>

\bibitem{base13}
httpuv, R Package.
<https://cran.r-project.org/web/packages/httpuv/index.html>

\bibitem{base14}
layoutEnginePhantomJS GitHub Repository.
<https://github.com/pmur002/layoutenginephantomjs>

\bibitem{base15}
PhantomJS - Scriptable Headless Browser, Home Web Page.
<https://phantomjs.org/>

\bibitem{base16}
layoutEngineCSSBox GitHub Repository.
<https://github.com/pmur002/layoutenginecssbox>

\bibitem{base17}
CSSBox Rendering Engine, Home Web Page.
<http://cssbox.sourceforge.net/>

\bibitem{base18}
W3C Standards, Web Design and Applications.
<https://www.w3.org/standards/webdesign/>

\bibitem{base19}
The Selenium Browser Automation Project, Home Web Page.
<https://www.selenium.dev/documentation/en/>

\bibitem{base20}
Docker Container Description.
<https://www.docker.com/resources/what-container>

\bibitem{base21}
NodeJS, Home Web Page.
<https://nodejs.org/en/>

\bibitem{base22}
layoutEngine::makeEngine() help page
<https://github.com/pmur002/layoutengine/blob/master/man/makeEngine.Rd>

\bibitem{base23}
Google, Tools for Web Developers, Puppeteer.
<https://developers.google.com/web/tools/puppeteer>

\bibitem{base24}
RSelenium R Package.
<https://cran.r-project.org/web/packages/RSelenium/>

\bibitem{base25}
Selenium Docker Hub.
<https://hub.docker.com/u/selenium>

\bibitem{base26}
Introduction to the DOM 
<https://developer.mozilla.org/en-US/docs/Web/API/Document\textunderscoreObject\textunderscoreModel/Introduction>

\bibitem{base27}
webpack DevServer. 
<https://webpack.js.org/configuration/dev-server/>

\bibitem{base28}
Express Server Project.
<https://expressjs.com/>

\bibitem{base29}
WebSocket API
<https://developer.mozilla.org/en-US/docs/Web/API/WebSockets\textunderscoreAPI>


\end{thebibliography}

\newpage
* Appendix
\sffamily  
\setlength{\parindent}{0em} 
*** layoutEngine Setup with RSelenium Backend

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
devtools::install_github("https://github.com/pmur002/layoutengine")
devtools::install_github("https://github.com/kcullimore/layoutenginerselenium")
library(layoutEngine)
library(layoutEngineRSelenium)
options(layoutEngine.Backend=RSeleniumEngine)

## Firefox Selenium docker image
firefox_build <- "3.141.59-20200525"
firefox_image <- paste0("selenium/standalone-firefox-debug:", firefox_build)

## Select which image to test
test <- list(name="firefox", image=firefox_image)
# test <- list(name="chrome", image=chrome_image)

## Enable X Server
system("xhost +local:")

## Load custom RSelenium Session 
RSSession <- rSSSession(url="127.0.0.1", portRS=4444, portClient="4444",
                 network="bridge", shm_size="1g",
                 browser_type=test$name, headless=FALSE,
                 image_request=test$image, fresh_pull=FALSE)
options(layoutEngine.rSSSession=RSSession)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

*** layoutEngine Setup with NodeJS Backend

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
devtools::install_github("https://github.com/pmur002/layoutengine")
devtools::install_github("https://github.com/kcullimore/layoutengineexpress")
library(layoutEngine)
library(layoutEngineExpress)
options(layoutEngine.Backend=ExpressEngine)

## Enable X Server
system("xhost +local:")

## Load custom NodeJS Session and set Backend
WSS <- WSSession(url="0.0.0.0", portServer=8080, portClient=8080,
                 network="host", fresh_pull=FALSE)
options(layoutEngine.WSSession=WSS)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  

\newpage 
*** Demo 1: Using multiple font types in the same graphical component 

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
layoutFonts <- c("Montserrat", "Taviraj", "Inconsolata")
CSSfonts <- cssFontFamily(layoutFonts)

ipsumText <- '<p>Lorem ipsum dolor sit amet <span class="text-1">consectetur adipisicing</span> elit. Omnis, esse vel? Dolorem <span class="text-2">cupiditate sunt dolor nesciunt molestias</span> eligendi aliquid, quae <span class="text-3">eaque maiores expedita a error, explicabo </span>, id magnam praesentium sit. <span class="text-4">Lorem ipsum dolor sit amet consectetur</span> adipisicing elit.</p>'

HTML <- paste0('
<div class="text-box">', ipsumText, '</div>
')

CSS <- '
.text-box {
  width: 600px;
  border-style: solid;
  color: #5c7080;
  margin: 20px;
  padding: 40px;
}
.text-1 {
font-family: Montserrat;
color: #0f9960;
}
.text-2 {
font-family: Taviraj;
}
.text-3 {
font-family: Montserrat-Black;
}
.text-4 {
font-family: Inconsolata;
color: #a82a2a;
font-size: 1.5em;
}
.text-5 {
font-family: Taviraj;
color: #0f9960;
}
'

png(filename="ex-1.png", width=600, height=200, units="px", type="cairo-png")
grid.html(html=HTML, css=CSS, fonts=CSSfonts)
dev.off()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/project/research/code/examples/ex-1.png]]
\textsf{Example 1: Using Multiple Font Types in the Same Graphical Component}
#+END_center 

\newpage
*** Demo 2: Show word wrap around transparent PNG

\BeforeBeginEnvironment{}{\begin{shaded}  

#+BEGIN_SRC R :exports code
##----------------------------------------------------------------------------80
png(filename="cars-plot.png", width=600, height=400, units="px", bg="transparent", type="cairo-png")
plot(mpg ~ disp, data=mtcars, xlim=c(40, 500), ylim=c(10, 35), axes=FALSE, cex=2, pch=2, col="red")
axis(side=1)
axis(side=2)
dev.off()

ASSETS = c("cars-plot.png")

ipsumText <- '<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Omnis, esse vel? Dolorem cupiditate sunt dolor nesciunt molestias eligendi aliquid, quae eaque maiores expedita a error, explicabo, id magnam praesentium sit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Omnis, esse vel? Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>'

HTML <- c('<div class="container">',
          '<div id="fig"><img class="image" src="assets/cars-plot.png/"></div>',
          ipsumText, 
          '</div>')

CSS <- '
.container {
width: 600px;
height: 400px;
padding: 20px;
border-width: 2px;
border-style: solid;
}
.image {
shape-outside: url("assets/cars-plot.png");
shape-margin: 20px;
float: left;
width: 580px;
}
p {
margin-top: 50px;
font-size: 0.85em; 
}
'

library(png)
carsPlot <- readPNG("cars-plot.png")
png(filename="ex-2.png", width=600, height=400, units="px", type="cairo-png")
flowedhtml <- flow(html=HTML, css=CSS, assets=ASSETS)
grid.html(flowedhtml, viewports=TRUE)
figvps <- grid.grep("fig", grep=TRUE, global=TRUE,
                    grobs=FALSE, viewports=TRUE)
downViewport(figvps[[1]])
grid.raster(carsPlot, vjust=1, hjust=0.5, width=0.9)
upViewport(0)
dev.off()
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  

#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/project/research/code/examples/ex-2.png]]
\textsf{Example 2: Embedded Graphics With Automatically Wrapped Text}
#+END_center 

\newpage
*** Demo 3: Complex layouts of text and graph components

\BeforeBeginEnvironment{}{\begin{shaded}  

#+BEGIN_SRC R :exports code

##----------------------------------------------------------------------------80
ASSETS = c("ex-2.png")

layoutFonts <- c("Montserrat", "Taviraj", "Inconsolata")
CSSfonts <- cssFontFamily(layoutFonts)

ipsumText <- '<p>Lorem ipsum dolor sit amet <b>consectetur adipisicing</b> elit. Omnis, esse vel? Dolorem <span class="text-4">cupiditate sunt dolor nesciunt molestias</span> eligendi aliquid, quae eaque maiores expedita a error, explicabo, id magnam praesentium sit. <span class="text-5">Lorem ipsum dolor sit amet consectetur</span> adipisicing elit. Rerum eligendi reiciendis aspernatur eaque fugit commodi doloremque aut soluta dolor, quaerat amet blanditiis quibusdam rem! Nesciunt nostrum dignissimos ad commodi reiciendis.</p>'

HTML <- paste0('
<div class="graphic">
<div class="A"><h1>A Large Title for this <span class="text-5">Graphic</span></h1></div>
<div class="B">', ipsumText, '</div>
<div class="C"><h1>This is some side Text...</h1></div>
<div class="D">
<span class="text-1">Montserrat</span>
<span class="text-2">Taviraj</span>
<span class="text-3">Inconsolata</span>
</div>
<div id="fig01" class="E"></div>
<div class="F">', ipsumText, ipsumText, ipsumText, '</div>
</div>
')

CSS <- '
body {
  padding: 0;
  margin: 0;
}
.graphic {
  display: grid;
  grid-gap: 10px;
  width: 1400px;
  grid-template-areas:
    " A A A F "
    " . B B F "
    " C E E F "
    " . D D F ";
  grid-template-columns: 200px 400px 400px 400px;
  grid-template-rows: 100px 1fr 600px 1fr;

}
.A {
grid-area: A;
background-color: #a6a5a5;
color: #293742;
text-align: center;
padding: 20px;
}
.B {
grid-area: B;
background-color: #f1f8ed;
padding: 20px;
}
.C {
grid-area: C;
background-color: #0a6640;
color: #ced9e0;
padding: 20px;
}
.D {
grid-area: D;
font-size: 2em;
background-color: #a7b6c2;
padding: 20px;
}
.E {
grid-area: E;
background: url("assets/cars-plot.png") no-repeat;
}
.F {
grid-area: F;
background-color: #5c7080;
color: #ced9e0;
padding: 20px;
margin-left: 40px;
}
.text-1 {
font-family: Montserrat;
font-weight: bold;
}
.text-2 {
font-family: Taviraj;
font-weight: bold;
}
.text-3 {
font-family: Inconsolata;
font-weight: bold;
}
.text-4 {
font-family: Inconsolata;
color: #a82a2a;
}
.text-5 {
font-family: Taviraj;
color: #0f9960;
}
'


carsPNG <- readPNG("ex-2.png")
png(filename="ex-3.png", width=1200, height=900, units="px", type="cairo-png")
flowedhtml <- flow(html=HTML, css=CSS, assets=ASSETS, fonts=CSSfonts)
grid.html(flowedhtml, viewports=TRUE)
figvps <- grid.grep("fig", grep=TRUE, global=TRUE,
                    grobs=FALSE, viewports=TRUE)
downViewport(figvps[[1]])
grid.raster(carsPNG)
upViewport(0)

dev.off()
    
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  

#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/project/research/code/examples/ex-3.png]]
\textsf{Example 3: Complex Layouts Of Text And Graph Components}
#+END_center 



\newpage  

\end{document}


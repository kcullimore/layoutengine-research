#+TITLE: COMPSCI 791 - Independent Research 
#+Author: Kane Cullimore (ID 286367861)
#+DATE: \today

#+LATEX_CLASS: article  
#+LATEX_CLASS_OPTIONS: [10pt]
#+LATEX_HEADER: \usepackage[a4paper,top=2.5cm,bottom=2cm,left=1.75cm,right=1.5cm]{geometry}

#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}

#+LATEX_HEADER: \setlength{\parindent}{3em}
#+LATEX_HEADER: \setlength{\parskip}{0.5em}
#+LATEX_HEADER: \renewcommand{\baselinestretch}{1.25}

#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{bold-extra}
#+LATEX_HEADER: \setmainfont{Taviraj}[Path = /home/krc/linCode/DOM_research/resources/fonts/Taviraj/, Scale=1.1, UprightFont = *-Light, BoldFont = *-SemiBold, ItalicFont = *-LightItalic, BoldItalicFont = *-SemiBoldItalic, ... ]
#+LATEX_HEADER: \setsansfont{Montserrat}[Path = /home/krc/linCode/DOM_research/resources/fonts/Montserrat/, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic, ... ]
#+LATEX_HEADER: \setmonofont{Inconsolata}[Path = /home/krc/linCode/DOM_research/resources/fonts/Inconsolata/, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ...]
#+LATEX_HEADER: \usepackage {titlesec}
#+LATEX_HEADER: \titleformat{\section}{\LARGE\sffamily\bfseries}{\thesection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsection}{\Large\sffamily\bfseries}{\thesubsection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsubsection}{\large\sffamily\bfseries}{\thesubsubsection}{.9em}{}

#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{graphbox}
#+LATEX_HEADER: \usepackage{minted}

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \definecolor{shadecolor}{gray}{.96}

#+LATEX_HEADER: \chead{CS-791}
#+LATEX_HEADER: \lhead{\today}
#+LATEX_HEADER: \rhead{Kane Cullimore}

#+OPTIONS: toc:nil title:nil author:nil date:nil

\bibliographystyle{unsrt}  
\bibliography{references}

\begin{document}

\begin{center}
  \LARGE\textbf{DOM package for R}
  \vspace{10mm} 
  \linebreak  
  \large\textbf{\textit{ Can web technologies help R generate print quality graphics? }}
  \vspace{10mm} 
\end{center}

#+BEGIN_center 
#+ATTR_LATEX: :width 3.5in  
[[/home/krc/linCode/DOM_research/resources/img/title_image.pdf]]

#+END_center 

\begin{center}
  \sffamily  
  \vspace{60mm} 
  \normalsize\textit{CompSci 791: Research Paper [Working version]}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{Kane Cullimore}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{\today}
\end{center}

\thispagestyle{empty}

\newpage 

\begin{abstract}  
\sffamily  
To be continued...
  
\end{abstract}  
  
\newpage  
\setcounter{tocdepth}{2}
\tableofcontents

\newpage 
\listoffigures


* Introduction  

The [[https://en.wikipedia.org/wiki/R_(programming_language)][R programming language]] [ref] is a popular tool to perform complex statistics for a variety of research and analyses. The language has many reliable libraries and methods to perform sophisticated statistical techniques within a relatively short amount of code.  
  
Humans working with statistics often benefit from the use of graphical representation of data to better understand and communicate its complexities. The base programming language has long supported rigorous graphical output that is accurate and effective \textit{(**better describe/explain**)}. However, niche use-cases which require additional graphical capabilities are popping up as the language is applied to a wider variety of applications. 

One such use-case is the requirement for a richer document formatting capability to produce highly custom print-quality graphical output. For example, users might want their plots to contain a very specific font type or a color gradient that smoothly transitions across the page. Such work is typically completed in external applications downstream from \textbf{R}.  These steps might use Adobe Illustrator or Photoshop or some other means to transfer the R output to a more refined graphic. 

The base graphics package within R does not attempt to cover such needs. There are several external packages that have extended its graphical capabilities in a number of ways. R can be used to drive an interactive web-based application with the Shiny package [ref]. A variety of aesthetically pleasing standard plots can be quickly generated with the ggplot2 package [ref]. A number of smaller packages also provide helper methods to enhance color selection [ref] or modify output file formats to make downstream work more smooth [ref - svg, grid?, etc?]. 

Despite these extensions there does not appear to be an smooth workflow to adhere to the most rigid graphical design requirements. The subject research explores whether this hypothesis is indeed true. It is possible that such a workflow may exist with some combination of existing packages which has not gained much attention. 

Following this effort, a newly developed packaged called "DOM" [ref] is reviewed to determine if it might serve this function. Depending on the outcome of this review the package might be extended to improve its use within such an application. 
  

\newpage  
* Research Methodology  
   
\textbf{ To Be Continued...}

- Present the need  
- Identify key factors of success to meet this need  
- Present a way to measure and test the solution's ability to meet these needs  
- Define the product design  
- Review its performance   
- Suggest and explore possible areas to improve   
- Compare solution and any enhancements against current solutions  
- Provide final recommendations based on these findings   

\newpage  
* Market Need  
  
Often statistical analyses lead to published communication of results. This might be contained within websites, books, journals or television. These more refined versions of graphical output are enhanced to better communicate, adhere to brand strategies and perhaps lead to improved reader engagement with delightful aesthetics.  

The core functionality of R is focused on the rigors of statistical analysis and the accurate and faithful representation of data. However, many \textbf{R} users work within industries that generate published work. Its this subset of \textbf{R} users and their industries that stand to benefit from the \texttt{DOM} package.   



** Print Quality Graphics   

There are several aspects of generating print quality graphics. They can be categorized into the following groups: (1) content, (2) layout, (3) rendering, (4) file format and (5) print quality. 
  



*** Content  
  
The publishing world relies heavily on customized visual content to help communicate in various ways. Colors are altered to improve the readability for the color-blind or for other environments such as a bright display screen. The selection and styling of font can be an art all unto itself. Icons and graphics can be added to draw attention or better communicate the characteristics of the data. 

The standard \textbf{R} graphics output are well designed for an audience whom are primarily interested in the data alone. As an example, there are standardized sets of data-point icons [ref and provide figure] and a basic coverage of font options. However, to meet the needs of the publishing industry a much more flexible system is needed to allow custom user-defined options to be used within the graphics. \textbf{Provide example...} 

\noindent  
- Custom fonts (?) 
- Mathematical equations  
- Data point icons   
  

*** Layout  

The layout of content within books, magazines and websites is an especially important aspect of generating print quality graphics. The standards of typesetting have a long history and many general rules and guidelines exist within the publishing industry [ref]. 

Traditional typesetting often arranges content within a grid system that adheres to well-known relationships with other components on the page. Graphic design professionals will often make slight tweaks that are difficult to prescribe within a predefined set of layout options. Rather, a flexible system that allows full control of all content positioning axes is needed.  
  
\noindent  
- Fine typesetting controls   
- others(?)  
  

\vspace{10mm}
\noindent
\textbf{Include diagram of what the typesetting might include (similar to Rahlf's book (Chp 4))}  
  

*** Rendering  

To meet the rich aesthetics of the publishing industry a powerful rendering engine is needed to cope with a variety of visual requirements. These include fine control of colour, gradients, resolution, scale, etc.  
  
R has very high quality rendering engine in its baseline configuration however there are a number of features it does not support. 
  
\noindent  
- Color gradients
- others(?)  
   

*** File Format  

R has a strong capability in its support of various file formats. There are several file format types which are preferred by users generating print quality graphics. Such file types help maintain quality, information preservation, consistency across the industry and performance (file size, read/write speeds, etc).  
  
\noindent  
- Vector: PDF and PostScript  
- Raster: PNG, JPEG and TIFF  
- XML: SVG  
- Web: HTML, CSS and JavaScript  
  


*** Print Quality 

Often a user is most interested in generating a final product in the form of a print. This could be a PDF file of a defined size and adheres to specified color gamut.  

\noindent  
- Vector: PDF and PostScript print  
- Raster: PNG, JPEG and TIFF print





\newpage  
** Target User  
  
Possibly generate a survey????? Could contact Julia Silge (now at RStudio ) to see how she conducted her survey found here: https://github.com/juliasilge/packagesurvey  
  
    
\vspace{6mm}  
\noindent  
Questions:  
\scriptsize  
- What industry do you work within?   
- What percentage of your work overall is performed within R? 
- What percentage of your work results in the output of graphics and plots to communicate results?  
- What percentage of your R graphics projects require post-processing to meet publishing requirements not available within R?   
- Would you utilize R to perform these steps if the functionality was available within an R environment?  
- What industries or fields do you seek out for expertise on publishing?  
  - Book and magazine production
  - Website development
  - Photography  
  - Graphic Design  
  - Others? Please specify...
- Which of the following do you perform in this post-processing (see key for clarification)?  
  1) Content
  2) Layout
  3) Rendering
  4) File format alterations
  5) Print
- Which of the following do you perform most often? 
  1) Content
  2) Layout
  3) Rendering
  4) File format alterations
  5) Print
- Are there any additional publishing specific steps you take not categorized within these groups?
- Which tools do you typically use for these post-processing steps?
  - LaTeX
  - Adobe suite or comparable alternative 
  - Others: Please specify...

Key: 

\normalsize

\newpage  

\noindent  
Industries and fields with \textbf{R} users that might find benefit in \texttt{DOM}: 

- Journalism  
  
- Academic and Scientific Research  
  - Articles
  - Reports
  - Magazines  
  
- Business   
  - Financial reports   
  - Technical communication (with consumers, users, etc) 
  - Marketing  
  
  
- Technical publishing  



\newpage  
** Existing Solutions with R 
  
Extensions have made the output graphics reach a broader variety of plot-types and effectiveness of the visualization [ref Paul's book with respect to lattice and ggplot]. However, most often the final published versions have undergone typesetting within an external post-processing step. 


The current industry employs various tools and methods to achieve these outcomes. LaTeX is a very popular method for publishing documents. The Adobe suite of tools are used for a range multi-media mediums such as websites and large advertisement prints. Several others exist but are not introduced. 
  

*** LaTeX Environment  

LaTeX is a widely used and rich typesetting programming language that can be used to publish text books, journals, reproducible research [ref ]. The following example shows how a plot generated within R can be transformed into a much richer document.  

\vspace{10mm}   
\noindent  
\textbf{NOTE: Just a placeholder. Will use a better example and reformat to better show workflow. }
\vspace{10mm}   
  
\begin{minipage}{0.8\textwidth}
\includegraphics[align=c,height=1.5in]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
  \hspace*{.2in}
  \LARGE\rightarrow
  \hspace*{.2in}
\includegraphics[align=c,height=2.5in]{/home/krc/linCode/DOM_research/resources/img/example_latex_graphic.pdf}
\end{minipage}


\scriptsize  

#+BEGIN_SRC latex :exports code
\documentclass{article}
\usepackage[paperheight=28cm, paperwidth=36cm, top=0cm, left=0cm, right=0cm, bottom=0cm]{geometry}
\usepackage[french]{babel}
\usepackage{multicol}
\usepackage{graphicx,color}
\usepackage{fontspec} 
\usepackage[abs]{overpic}
\setmainfont{Montserrat}[Path = /home/krc/linCode/DOM_research/resources/fonts/Montserrat/, Scale=MatchLowercase, Mapping=text-tex, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic]
\setlength{\columnsep}{1cm}
\definecolor{mybackground}{rgb}{.88,1,.88}
\definecolor{text-1}{gray}{.55}
\definecolor{text-2}{gray}{.25}
\pagecolor{mybackground}
\begin{document}
\pagestyle{empty}
\begin{center}
  \fontsize{12pt}{17pt}\selectfont
    \begin{overpic}[scale=1, unit=1mm, trim=0cm 0cm -6cm -4cm, clip]{./../../code/experiments/03/R/output/barcharts_simple.pdf}  
      \put(4,-50){\begin{minipage}[t]{20cm}
          \begin{multicols}{2}
            \textcolor{text-1}{Les nombres d’hommes présents sont représentés par les largeurs des zones colorées a raison d’un millimètre pour dix mille hommes ; ils sont de plus écrits en travers des zones. Le gris désigne les hommes qui entrent en Russie, le noir ceux qui en sortent. Les renseignements qui ont servi à dresser la carte ont été puisés dans les ouvrages de MM. Thiers, de Ségur, de Fezensac, de Chambray et le journal inédit de Jacob, pharmacien de l’ar- mée depuis le 28 octobre. Pour mieux faire juger à l’œil la diminution de l’armée, j’ai supposé que les corps du prince Jérôme et du Maréchal Davoust qui avaient été détachés sur Minsk et Mobilow et ont rejoint vers Orscha et Witebsk, avaient toujours marché avec l’armée}
          \end{multicols}
        \end{minipage}}
      \put(-6,180){\begin{minipage}[t]{20cm}
          \fontsize{40pt}{20pt}\selectfont
          \bfseries 
          \textcolor{text-2}{Les nombres d’hommes}
        \end{minipage}}    
    \end{overpic}
\end{center}
\end{document}
#+END_SRC 
  
\normalsize


*** Graphic Design Software  

There are many graphic design and publishing software packages available. Most are designed for the use by artistic professionals with Graphical User Interfaces (GUI) controls. Many also have the ability to be extended via macros or other methods to programatically control the work flow. \textbf{Adobe} [ref] offers a suite of software and is a market leader in this field.  
  
\vspace{10mm}   
\noindent  
\textbf{NOTE: Just a placeholder. Will include an example of using Illustrator and InDesign}
\vspace{10mm}   
  
 
\newpage   

** Important Criteria  

A major factor in adoption of a tool or process within this field would rely on users gaining the functionality to meet industry standards. These requirements are deeply technical and complex. As such, providing such functionality by building it all into a new system would be a monumental task. A more viable option would be to link the R environment to another existing system which is rich, popular and already accepted within the industry as meeting its needs. 

Although the various extensions of R might offer bespoke support for various items outlined above, there does not appear to be a single ecosystem or workflow that meets the full needs of the target market need.  


*** Benefits

- Performance  
  - Print quality  
  - Flexibility
  - Generalization  



- Functionality  
  - Layout Tool  
  - Rendering  

  

*** Costs

- Subscriptions
- Workflow



- Developer Experience  
  - Learning curve
  - Context switching
  - Taking advantage of other ecosystems (network effect (i.e. JavaScript & NodeJS packages vs LaTeX & Adobe))  
  - Complexity
  - 

- System Dependency
  - Ease of 




\newpage  

* The DOM Package  
  
This section first introduces the \texttt{DOM} package and describes the design intent and how it is implemented. Following this are several examples which demonstrate how it can be used to generate print quality graphics. These examples were chosen to showcase it use across the various aspects of publishing print quality graphics.   


** Description  

*** Design Intention    
  


The \texttt{DOM} package is built with several existing packages described below. The package intends to meet the solution design described above. The package has been through several development cycles at the time of this report. These improvements have focused on...(capture main items). 
  
The package is not focused on generating interactive web applications such as the \texttt{shiny} package. Rather, the it is designed to incorporate web technologies to improve desktop publishing, typesetting and layout functionality (see LaTeX stack, Adobe, others??).  (Reword => Intended as generating CODE interfaces (not graphical interfaces)...(I need to understand this better))

In the same way a web-technology stack that goes about this with HTML, SVG and JavaScript the \texttt{DOM} package would intend to build a HTML, SVG and R stack (? reword...).  

  
A primary goal of the \texttt{DOM} package is to perform typesetting post-processing tasks while remaining in the R environment. This being as opposed to taking an unfinished graphic output as a \textbf{pdf} file into other environments such as LaTeX or Adobe tools. 

\texttt{DOM} aims to achieve this by employing the web standards set in HTML, CSS and JavaScript. The R plot would be sent along with such code into a web browser which would render the final document. 

The benefit of such a work-flow lies in taking advantage of one of the richest consumer focused programming environments that exists. \textbf{Find some reference pointing to the popularity and efficacy of this.}  
  
*** Use-case scenerios  
  
Need diagram to show various paths to use \texttt{DOM}  


- Some plot -> gridSVG -> SVG -> Render in browser or phantomJS -> code for layout or print
- data frame -> xtable -> HTML -> Render in browser or phantomJS -> code for layout or print
  

- Review \texttt{layoutEngine} which will take HTML code and incorporate back into R graphics  

\newpage  
*** How it Works 
  
- An R session will act as a web server by hosting a web page within the local network (i.e. 127.0.0.1:port a.k.a. localhost:port)  
- The web page is only accessible on the local machine and not intended to be publicly hosted  
- A user will then interactively generate a graphical output within the browser window essentially using the browser window as their \textit{canvas} which provides the visual feedback   
  - This will be achieved by first setting up an initial html template based on predetermined needs (width/height, colour schemes(?), layout(?), etc)  
  - The graphic components are then built with packets of web data by pushing it from the server (e.g. laying down the axes and scales first, then the data points and then the text boxes)  
  - Information from the browser will be sent back to the server since some component data might depend on browser information such as knowing exact size or locations of the page elements relative to each other  
  - It is possible (as the package evolves) the user might interact with the web page and therefore send data back to the browser via requests (e.g. changing an axis range or exporting) however, since the same user has control of the browser via the server this secondary control avenue doesn't seem necessary  
- Once the graphic is completed the user might export this as a file either as web data (html, xml, etc) or as a rendered image (pdf, png, etc)    



#+BEGIN_center 
#+ATTR_LATEX: :width 5in  
[[/home/krc/linCode/DOM_research/resources/img/solution_1.pdf]]

#+END_center 



\newpage  
*** Technical Deep Dive  

**** Technical requirements  
  
The general requirements to support this solution design are:  
1) The R session must create a non-blocking web server to locally host the web page as a background service while allowing the user to interact with it  
2) Various html templates and accompanying arguments (e.g. screen width/height) must be able to be selected and loaded upon initialization of the web page  
3) A browser on the local network will launch to the web page with a specified URL (either launched automatically or manually)  
4) The server will iteratively push updates to the web page description  
5) The browser will automatically update its rendered version of the web page upon any changes pushed by the server  
6) The browser will be able to send data back to the server either by (1) request of the server (i.e. a server query) or (2) in response to any update pushed to the browser  
7) \textbf{ON HOLD:} User can send requests to the server via a browser interface (forms, buttons, sliders, etc)  
8) The final result must be able to be exported as (1) code and (2) a rendered image   
  


#+BEGIN_center 
#+ATTR_LATEX: :width 6in  
[[/home/krc/linCode/DOM_research/resources/img/solution_2.pdf]]

#+END_center 




\newpage  
**** R Package Design   
  
\noindent    
The \texttt{DOM} package is built with the following packages: 
  
1) \texttt{methods}: S4 class system  
2) \texttt{utils}: Basic methods for launching default browser, capturing output and extracting the package version  
3) \texttt{httpuv}: The HTTP and WebSocket server functionality  
4) \texttt{jsonlite}: To transfer data between R and the browser via JSON  
5) \texttt{whisker}: A HTML template building system  
6) \texttt{Rook}: A HTTP message specification that \texttt{httpuv} adheres to  
  
\noindent  
When \texttt{DOM} is loaded into R several parameters are written to the global options from which R can access programatically (i.e. review via \textt{.Options})  
  
- \texttt{DOM.client} includes the basic functions to launch the application via \texttt{httpuv}, run the browser session and kill the server.  
- \texttt{DOM.debug} is a flag for...
- \texttt{DOM.limit} is the maximum number of concurrent server sessions to create (default to 5)  
- \texttt{DOM.width} is the DOM.window width (default at 800 px)  
- \texttt{DOM.length} is the DOM.window length (default at 600 px)  


\newpage  
**** Inner Workings 

The \texttt{DOM} package has a very simple process for establishing a blank (or simple) HTML page. The \texttt{hmltPage()} method used to achieve this [ref] abstracts several processes from the user.   The following section breaks down what is happening under the hood.  


    
\begin{wrapfigure}{R}{0.4\textwidth}
\centering
\includegraphics[width=0.35\textwidth]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
\caption{R Plot Output}
\vspace{-5mm}
\end{wrapfigure}

The \texttt{DOM} package has a very simple process for establishing a blank (or simple) HTML page. The \texttt{hmltPage()} method used to achieve this [ref] abstracts several processes from the user. The following section breaks down what is happening under the hood.  
  
\setlength{\parindent}{0em}

A basic web page is defined with a single element in the form of a paragraph tag with some text; \texttt{"<p>Some text lies here...</p>"}. The \texttt{DOM} package initiates this simple web page with the following commands. Although this is small amount of code there is a lot going on in the background. 

\begin{minipage}{0.6\textwidth}
\BeforeBeginEnvironment{}\{\begin{shaded}
\begin{minted}[breaklines=true,breakanywhere=true]{r}
library(DOM)
text <- "<p>Some text lies here...sdafsdf</p>"
p <- htmlPage(text)
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}
\end{minipage}

\setlength{\parskip}{0em}  


\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC r :exports code 
library(DOM)
text <- "<p>Some text lies here...</p>"
p <- htmlPage(text)
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}  

  
When the \texttt{DOM} package is loaded there are several objects loaded into the global options list. These are defined in the previous section. The \texttt{DOM.client} object is of special interest here since it defines a \texttt{app}, \texttt{run} and a \texttt{kill} method for use with the server calls. 

\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code 
library(DOM) ## Loads methods and generates 5 objects within the global options 
## 1) DOM.client with 3 methods
## $app: the primary function used to define the server logic when the web page is launched 
## $run: the function that is called to launch the browser on the host machine
## $kill: the function called to clean up when the server is shut down 
## 2) DOM.debug is set to FALSE 
## 3) DOM.limit is set to 5
## 4) DOM.width is set to 800
## 5) DOM.length is set to 600

#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
The \texttt{htmlPage()} method is run with the following default arguments. This function is defined within the \texttt{Page.R} file. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
text <- "<p>Some text lies here...</p>"
p <- htmlPage(html=text, ## Body of web page at initiation 
              head="", ## Arguments to place into the HTML header
              host="127.0.0.1", ## The URL address for localhost
              client=getOption("DOM.client") ## Default definition of the server logic
    ) 
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Once the \texttt{htmlPage()} function is called several things happen in the background. Most notably is a list of hosted pages and responses is created to keep track of them. Therefore each page and response associated with a page has a pointer object to identify it. 
The \texttt{getPageID()} function is defined within the \texttt{Page.R} file while the \texttt{getResponseID()} and \texttt{addRequest()} functions are defined within the \texttt{DOM.R} file. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## Inside of the htmlPage() call the following steps are taken 
pageID <- getPageID() ## Assigns an integer value which is kept within a list of page IDs
tag <- getResponseID() ## Assigns an interger which is converted to a character 
                       ## This tag is associated with each call to update a PageID  
## The following function call adds the new tag to the list of open requests  
addRequest(tag=tag ## New tag values
           async=FALSE ## Whether the request should block (syncronous) or not (asynchronous)
           callback=NULL ## If the request is asynchronous then what callback to use 
           returnType="NULL" ## ?? 
           pageID=pageID ## The pageID the request is assoicated with  
           )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Next the \texttt{htmlPage()} function calls the \texttt{startDOMServer()} function which is defined within the \texttt{Page.R} file. This function takes the arguments defined so far and sends it to \texttt{httpuv::startServer()} which is the primary mechanism to launch the server and host the web page.  
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## The arguments are passed from htmlPage() and the newly created page and response ids
startDOMServer(pageID=pageID, ## id assigned to the server instance
               host=host,  ## URL to launch the web page with
               app=client$app, ## from the global options
               port=NULL, ## Currently the port # is randomly assigned at the next step
               body=html, ## html content to pass along
               head=head, ## any headers to add to the web page
               tag=tag ## the request id              
               )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

Once the server has been successfully created via the \texttt{httpuv::startServer()} function the following steps are taken. 
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+BEGIN_SRC R :exports code
## 1) The randomly assigned port # is captured in a private variable 
port <- pageInfo(pageID)$port  
## 2) The defined client$run method is called
## By default a browser is openeded and navigated to the specified URL  
client$run(url=paste0("http://", host, ":", port, "/")
           host=host,
           port=port,
           tag=tag          
           )
## 3) The active response is added to a list to track when its resolved 
waitForRequest(tag=tag,
               limit=getOption("DOM.limit"), ## Default value for number of open requests
               onTimeOut=function() closePage(pageID) ## Used to prevent indefite hanging 
               )
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}



To be continued...



\setlength{\parindent}{3em}
\setlength{\parskip}{0.5em}




\newpage  
** Examples  
  
A series of examples are provided to demonstrate how \texttt{DOM} can be used to perform the various aspects of generating print quality graphics. All are intended on being reproducible within the Docker environment explain in the appendix [ref].  

*** A simple overview 

The following overview describes a simple workflow to use R to create a plot and then add some styling and additional components within the browser. 
  
\setlength{\parindent}{0em}
  
\begin{minipage}[c]{0.55\textwidth}
\begin{enumerate}
\item Generate a plot within R using a grid based package (\texttt{grid}, \texttt{lattice} or \texttt{ggplot2})    
  
\item Convert the plot to \textbf{SVG} with \texttt{gridSVG}
  
\item Initiate a webpage with \texttt{DOM} and navigate to the URL with a browser to initiate the WebSocket connection  
  
\item a;lsdkfj;lasdkfj;alsdkfj;alsdfkj   
\end{enumerate}
\end{minipage}   
\hfill
\begin{minipage}[c]{0.45\textwidth}
\centering
\includegraphics[width=0.8\textwidth]{/home/krc/linCode/DOM_research/resources/img/example_R_graphic.pdf}
\end{minipage}

\setlength{\parindent}{3em}


*** Content  

\noindent
Ideas: 
- Custom icons as data points
- 

*** Layout  

\noindent
Ideas: 
- 2 or 3 column layout over plot 
  - Various justified
  - with CSS-grid
- Generate different plot layouts for various screen (or document) sizes
  - with CSS-grid and media queries  

*** Rendering  

\noindent
Ideas: 
- Gradient fill along bars
  - with gridSVG and push across
  - with CSS styling
  - 

*** Exporting    
  
\noindent
Ideas: 
- Using 

\newpage  
** Performance  

*** Web technology overview  

**** HTML Standard  
  
The specification for the HTML standard is constantly evolving. This is generally a good thing as new technologies are continuously evolving and improving the web experience. However, the continuous updates creates a moving target to developers of both the web browsers as well as websites.  
  
The HTML specification is controlled by the World Wide Web Consortium (W3C) [ref]. Various browsers support most of the newly available definitions being released however not all are in sync. The browsers that typically support the latest specifications sooner are Mozilla Firefox [ref] and Google Chrome [ref]. Apple Safari [ref] is often not far behind. Microsoft has notoriously been sluggish in their adoption of the latest specification with its Internet Explorer browser which was only updated along with its Windows operating system. Most recently Microsoft's superseeding browser, Edge [ref], is much better in its support.  

For the use of development it is recommended that either Firefox or Chrome are used with \texttt{DOM}. The discussion of potential updates to \texttt{DOM} will take into consideration the need to be compatible with Safari and Edge into the future.  

**** Browser Engines   

Each available browser currently available to the public is built with its own browser engine. Each of these engines offer varying performance and support a slightly different coverage of the HTML specification. 

\setlength{\parindent}{0em}  
  
The primary browser engines that will be considered during developement of \texttt{DOM} are as follows:
  
_Mozilla: Gecko_    
- Firefox and Thunderbird email client   
  
_Google: Blink_    
- Google Chrome, Chromium based browsers, Microsoft Edge, Brave and Opera   
  
_Apple: WebKit_  
- Safari and iOS hosted browsers  
  
_Universal Microsoft Platform: EdgeHTML_   
- Windowns 10, Windows 10 Mobile, Halolens, Xbox One  
   


References:  
- General Comparison:  
https://en.wikipedia.org/wiki/Comparison_of_browser_engines  
- HTML support:  
https://en.wikipedia.org/wiki/Comparison_of_browser_engines_(HTML_support)  
- CSS support: 
https://en.wikipedia.org/wiki/Comparison_of_browser_engines_(CSS_support)  
- Graphics support: 
https://en.wikipedia.org/wiki/Comparison_of_browser_engines_(graphics_support)  
- Typography support: 
https://en.wikipedia.org/wiki/Comparison_of_browser_engines_(typography_support)  
  
\setlength{\parindent}{3em}  

**** Browser Tools 

Within each browser are a suite of tools that might be useful for designing and debugging a web page. 




  

\newpage   
* Future Development 
  
** Opportunities  
  
There are several areas which have been recognized as areas of future development to improve its performance and effectiveness.  
  
1) Verify the communication between R and the web-page is optimal (and/or improve some how) (this would include reviewing the package used for creating the server is best suited to intended solution design)
2) Review the use of DOM's asynchronous event handling and possible incorporate existing packages such as \texttt{futures} or \texttt{promises}   
3) Extend the coverage of the \texttt{DOM} elements and methods to suite the bulk of the needs for recognized use-cases  
4) Get the package working on Windows  

  
In addition to the above areas of opportunities for advancement, additional examples of using \texttt{DOM} to meet the target use-cases would also be beneficial (i.e. generating print quality graphics with \texttt{DOM} vs other workflows). 



*** Web Server Design  

Viable options to achieve the technical requirements are:  

\setlength{\parindent}{0em}  
_Req. 1: R based web server_  


A number of packages exist to enable R to act as a HTTP server on the local machine. The most popular low-level package is RStudio's \texttt{httpuv} package which can host both HTTP and WebSocket connections. Many other packages are built upon \texttt{httpuv} to provide additional functionality or improve the ease of use. 

A limiting factor in this choice is the need to \textbf{push} data to the browser which will either require a WebSocket connection or via HTTP/1 or HTTP/2 with Server-Sent Events (SSE). Without such a feature the user would have to refresh their browser each time the graphic design was altered and updates were incorporated into the content. A comparison of these is provided in the following section. While the WebSocket connection most likely has better performance there is a trade-off in the complexity of the server logic versus a HTTP with SSE connection.  

- httpuv  
  - HTTP and WebSocket server library for R  
  - Relatively low-level and most other R server options build a layer onto it  
  - call(req) method adheres to Rook specification  
- fiery  
  - Built on httpuv  
  - Supports HTTP and WebSocket  
  - Used with package \texttt{reqres} and can be extended with \texttt{routr} by same developer 
  - NOTE: \texttt{routr} attempts to provide a similar developer experience which the popular Express.js package does for NodeJS servers   
- shiny  
  - Built on httpuv  
  - Web-app library that is very high-level  
  - Comes with a lot of functionality designed for developers to build interactive web-apps from R code  
  - Much of the trade-off for the abstraction is a less flexible developer experience  
- others  
  - If HTTP with SSE is deemed adequate there are several other server packages that should be evaluated. 
  - Some are built on top of \texttt{httpuv} and others are stand alone  

References:  
- WS vs SSE discussion:
  - [[https://www.infoq.com/articles/websocket-and-http2-coexist/ ]]
- SSE:
  -  [[https://en.wikipedia.org/wiki/Server-sent_events]]
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events]]    
- EventSource (SSE):
  -  [[https://developer.mozilla.org/en-US/docs/Web/API/EventSource]]
- HTTP/2: 
  - [[https://developers.google.com/web/fundamentals/performance/http2]]
- Rook:
  - [[http://epbi-radivot.cwru.edu/EPBI415/files13/wk14RwebApps/Rook/Building%20Rook%20Web%20Applications.pdf]] 
  -  [[https://jeffreyhorner.tumblr.com/post/4723187316/introducing-rook]]  
  -  [[https://www.r-bloggers.com/a-simple-web-application-using-rook/]]  
   
_Req. 2: HTML templates_  
- whisker  
- Custom coded? 
   
_Req. 3: Browser launch_	 
- Automatically with \texttt{utils::browseURL()}  
- Manually navigate    
   
_Req. 4: Server update to web page_  
- HTTP/1 with Server-Sent Events (SSE)  
- HTTP/2 with Server-Sent Events (SSE)  
- Websocket server  
  

_Req. 5: Live browser refresh_  
- HTTP/1 with Server-Sent Events (SSE)  
- HTTP/2 with Server-Sent Events (SSE)  
- Websocket client via \texttt{websocket} package    
  
References:  
- websocket client package: https://github.com/rstudio/websocket

_Req. 6: Web page data to server_  
- Full \textit{data-dump} within response from web page update (?)  
- Server query event of \texttt{DOM}  (?)  
- Websocket  

References: 
- document.querSelector: https://www.w3schools.com/jsref/met_document_queryselector.asp
   
_Req. 7: (ON HOLD) Browser interactions_	 

   
_Req. 8: Final graphic export_	 



\setlength{\parindent}{3em}  


**** websocket server  
  
**** Layout engine  
  
**** Renderer  



  


  
\newpage  

*** Asynchronous Event Handling    
 

*** HTML Element Coverage  


*** Use Across all Operating Systems 


** Preliminary Investigations   


\newpage  
* Conclusion  

** Review  

- Does the market have a need for such a product?  
  
- Is DOM a competitive offering to meet this market need?   

- Should DOM be developed further?  

- Are there any opportunities to improve that would add significant benefits?  
   

** Recommendations  


** Summary 

\newpage
\appendix
\addappheadtotoc
* Appendix  


\sffamily  
\setlength{\parindent}{0em}    
** Development Environment

A single Docker container is used to perform research, experimentation, R package development and documentation. This environment was chosen to easily share the development content with others for collaboration and feedback. It will also ensure that any future return to this research can be resurrected with a working code-base independent of software changes.  
   
 
The report and R development have been performed within Emacs and ESS environment inside of the Docker container. The report is written within the Emacs org-mode markdown language which abstracts some LaTeX syntax while also providing literate programming options which are more flexible than generic markdown or Rmarkdown.  
  
    
Some basic Docker and Emacs commands are provided to walk the user through some of aspects of the build and editing processes. 


*** Docker container description  
  

_Overview_: The Docker container is publicly available on [[https://hub.docker.com/][Docker Hub]] with the following image name \textbf{kcull\textbackslash dom\_r}. The container is built from the Ubuntu 18.04 image and has R 3.6.1 and Emacs 26.3 installed. The container has been configured to run Emacs in its GUI environment on the host machine. 
  
\noindent
_User and Home Directory_: The user is logged in as a sudo-user with \texttt{/home/user/} as the $HOME directory. The sudo password is "password." The working directory is \texttt{/project/} which both the shell and Emacs will initialize into. 

\noindent
_Directory Organization_: The project is organized into 2 main directories which are each linked to github repositories. Directory 1 is the forked \texttt{DOM} package which is extended per this research. Directory 2 is the research effort which contains the experimental code and files used to create this report. Both directories should be created and maintained on the host machine and then connected to the Docker container with a \textbf{bind mount} option when the container is running. 
  
\noindent
_Directory Hierarchy_:  
  
#+BEGIN_SRC bash :results none :exports code  
# Emacs configuration files   
/home/user/.emacs.d/ 
# Github repository for R DOM package
/project/DOM/     
# Github repository for research documentation   
./../../ 
# Experimental code for research  
./../../code  
# Files to generate report    
./../../paper 
# Miscellaneous files such as the Dockerfile, Fonts, Images, etc.    
./../../resources 
#+END_SRC  
  

 
*** Host setup and Docker run instructions 

The following instructions are provided to recreate the development environment. This has only been tested from within a host machine running Ubuntu 18.04 but is assumed to be compatible with other Debian derivatives. The Dockerfile used to build the container is supplied which should enable the necessary tweaks to support other host machine environments. 

\setlength{\parindent}{2em}  
    
1 - Ensure docker and git are installed and correctly configured to download the docker image and clone repositories.  

2 - Obtain access to the private github repository, [[https://github.com/kcullimore/DOM_research]], for the research content by emailing myself at <kane@ia.house>. The \texttt{DOM} package, [[https://github.com/kcullimore/DOM]], is publicly available.  

3 - Create a working directory on the host machine and clone each github repositories as shown below:  
  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Example folder structure  
mkdir -p ~/project/{DOM,research}
## Clone repositories
git clone git@github.com:kcullimore/DOM.git ~/project/DOM
git clone git@github.com:kcullimore/DOM_research.git ~/project/research
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
4 - Run the following commands within the host terminal but first ensure the target directories are correct per Step 3 (i.e. verify source= \textbf{/home/\$USER/proj...} is correct). 

  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Open host machine devices to container (only need to do once per reboot)
xhost +local:
## Run docker container linked to directories with bind-mount  ------------------
docker run --rm -it \
       --network host \
       --env DISPLAY=unix$DISPLAY \
       --volume /tmp/.X11-unix:/tmp/.X11-unix \
       --mount type=bind,source=/home/$USER/project/DOM/,target=/project/DOM/ \
       --mount type=bind,source=/home/$USER/project/DOM_research/,target=./../../ \
       --name dom-test \
       kcull/dom_r:latest 
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
\newpage  

5 - Once the docker container is up and running verify folder structure has correctly mapped the host directories.  
  
6 - Open Emacs in the container's terminal: \texttt{\$ Emacs}. The host should launch Emacs in its GUI form (i.e. not within the shell). If this doesn't occur verify steps 4 were followed thoroughly (NOTE: After reboot the display device will have to be provided access again with the \texttt{\$ xhost +local: command). 

7 - From within Emacs perform the following operations to open and recreate the current report 
  
- Opens Treemacs with \texttt{M-0}
- Open folder structure to \texttt{./../../paper/} with Tab-Enter or Mouse  
- Open org-mode markdown file \texttt{/paper\_working.org} with Enter or Mouse double-click 
- Make some edits to the file and save with \texttt{C-x C-s}    
- Launch Export Dispatcher menu with \texttt{C-c C-e}  
- Create new PDF file with \texttt{C-l C-o}  
  
8 - The PDF should have opened automatically which you can scroll through with arrow keys or the mouse scroll wheel.  Use \texttt{q} key to minimize the PDF buffer.  
  
9 - Close Emacs with \texttt{C-x C-c} and exit the container by typing \texttt{exit} at the terminal. 

10 - Navigate to the project directory on the host machine and verify the new PDF and edited org-mode file were correctly saved. 

11 - If the above worked the project appears to be correctly established on the host machine.  
  
\newpage  
** Emacs within Docker Container 


*** Useful report editing commands
  
\setlength{\parindent}{0em}  
    
_Emacs Terminology_  
  
- \textbf{buffer:} 'Screen' or 'window' user operates within  
- \textbf{marking:} Highlighting region of window  
  
 
Often used commands can be found at [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf]].
  
  
 
_Customized keybindings_  
  
- Open emacs configuration file with \texttt{C-c e}  (Emacs must be restarted for changes)
- Expand all nested/hidden text within *.org file with \texttt{Shift-Tab Shift-Tab Shift-Tab}   
- Copy, cut and paste with standard keybindings per \textbf{Cua Mode}  
- Switch visual line wrap with \texttt{M-9}  
- Switch to truncate long-line view with \texttt{M-8}  
- Enter/Exit rectangle edit mode with \texttt{C-\string^}  
- Enter/Exit multi-edit mode by highlighting word and then \texttt{C-u}  
- Auto-indent R script (via ESS) by highlighting buffer with \texttt{C-x h} and then \textt{C-M-\}
  
  
_Document Export_ 
  
When a PDF version of the document is produced a standard TeX file (*.tex) is also produced after transpilation. This TeX file can be edited and used with a standard LaTeX command: \texttt{latex report.tex}.  
  
 

To be continued...
  
** Report Editing Process  
  

To be continued...
  
\newpage  
** Org-mode examples 

*** Font definitions 
\setlength{\parindent}{0em}  
  

Using LaTeX fontspec package \cite{type01}
  
\sffamily
_Sans_  
  
Internet based applications are an increasingly popular way to communicate and interact with complex data. 
  
\sffamily\itshape 
_Sans italic_  
   
Internet based applications are an increasingly popular way to communicate and interact wtih complex data. 
   
\sffamily\itshape\bfseries 
_Sans italic bold_  
   
This might include a business application that assist employees unverstand the current state of the market.
   
\normalfont 
_Serif_   
  
 It might also include a news website communicating techincal details from a story such census data. 
  
\normalfont\itshape 
_Serif italic_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont\itshape\bfseries    
_Serif italic bold_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont
\ttfamily    
_Mono type_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\bfseries
_Mono Bold type_

\texttt{\bfseries The quick brown fox 012456789}

\normalfont
\sffamily  
  


\newpage  
*** Sample R code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC R :exports code
##*******10********20********30********40********50********60********70********80
## Problem 2: START => Optical Illusion Example
##*******10********20********30********40********50********60********70********80
## Generate pdf file of plot (capture ends with dev.off() below)
pdf("prob-02.pdf", width = 3, height = 6)
## Create theta values  for each line segments (i.e. 180 degs / 4 = 45 segments)
## Remove elements in the center of vector (i.e. 80-100 degree section)
theta <- seq(0, pi, length = 45)[-(20:26)]
## Set parameters to be used in plot() (R = dummy radius, B = slope of lines)
R <- 1
B <- sin(theta) / cos(theta)
## Setup plot space and define coordinate axes (also remove 'edge buffer')
plot.new()
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.window(xlim = c(-R, R), ylim = c(-R, R), asp = 1)
## Create the black line segments
for (i in 1:length(B)) abline(a = 0, b = B[i], lwd = 2)
## Create the 2 red vertical lines
abline(v = c(-R/2, R/2), col = "red", lwd = 4)
## Stop image capture
invisible(dev.off())
##*******10********20********30********40********50********60********70********80
## Problem 2: END
##*******10********20********30********40********50********60********70********80


#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
  


\newpage  
*** Sample HTML code highlighting    
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC html :exports code
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1,
	    maximum-scale=1.0, user-scalable=0"
    />
    <!-- favicon -->
  </head>
  <body>
    <title>DOM - Testing Application</title>
    <div id="AppDiv" class="app-div"></div>
  </body>
</html>

#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

*** Sample CSS code highlighting      
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC css :exports code
.iah-text-Raleway {
  font-family: 'Raleway', sans-serif;
  font-weight: 500;
}

.iah-text-black {
  font-family: 'Roboto Mono', monospace;
  font-weight: 500;
  font-size: 2em;
  overflow-wrap: break-word;
  margin: 10px;
  color: var(--iah-grey-dark);
}
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

\newpage 
*** Sample JavaScript code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC javascript :exports code
var args = []; // Empty array, at first.
for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i])
} // Now 'args' is an array that holds your arguments.

// ES6 arrow function
var multiply = (x, y) => { return x * y; };

// Or even simpler
var multiply = (x, y) => x * y;    
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}  





\newpage  
  
* References  

   
\begin{thebibliography}{bib}

\bibitem{type01}

package used to manage fonts within xelatex (or luatex)
fontspec: http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/fontspec/fontspec.pdf


\end{thebibliography}




\end{document}




#+TITLlppE: COMPSCI 791 - Independent Research 
#+AUTHOR: Kane Cullimore (ID 286367861)
#+DATE: \today

#+LATEX_COMPILER: lualatexlp
#+LATEX_CLASS: article  
#+LATEX_CLASS_OPTIONS: [10pt]
#+LATEX_HEADER: \usepackage[a4paper,top=2.5cm,bottom=2cm,left=1.75cm,right=1.5cm]{geometry}

#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{setspace}

#+LATEX_HEADER: \setlength{\parindent}{1.5em}
#+LATEX_HEADER: \setlength{\parskip}{0.5em}
#+LATEX_HEADER: \renewcommand{\baselinestretch}{1.25}

#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{bold-extra}
#+LATEX_HEADER: \setmainfont{Taviraj}[Path = /project/resources/fonts/Taviraj/, Extension = .ttf, Scale=1.1, UprightFont = *-Light, BoldFont = *-SemiBold, ItalicFont = *-LightItalic, BoldItalicFont = *-SemiBoldItalic ]
#+LATEX_HEADER: \setsansfont{Montserrat}[Path = /project/resources/fonts/Montserrat/, Extension = .ttf, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic ]
#+LATEX_HEADER: \setmonofont{Inconsolata}[Path = /project/resources/fonts/Inconsolata/, Extension = .ttf, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold]
#+LATEX_HEADER: \usepackage {titlesec}
#+LATEX_HEADER: \titleformat{\section}{\LARGE\sffamily\bfseries}{\thesection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsection}{\Large\sffamily\bfseries}{\thesubsection}{.9em}{}
#+LATEX_HEADER: \titleformat{\subsubsection}{\large\sffamily\bfseries}{\thesubsubsection}{.9em}{}

#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \defaultfontfeatures{Ligatures=TeX}
#+LATEX_HEADER: \setmathfont{texgyrepagella-math}[Path = /project/resources/fonts/TexGyre/, Extension = .otf]

#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{graphbox}
#+LATEX_HEADER: \usepackage{minted}

#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \setlist{nosep}
#+LATEX_HEADER: \setlist[itemize,1]{label={â–¶}}
#+LATEX_HEADER: \setlist[itemize,2]{label={--}}

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \definecolor{shadecolor}{gray}{.96}

#+LATEX_HEADER: \chead{CS-791}
#+LATEX_HEADER: \lhead{\today}
#+LATEX_HEADER: \rhead{Kane Cullimore}

#+OPTIONS: toc:nil title:nil author:nil date:nil

\begin{document}

\begin{center}
  \vspace{10mm} 
  \LARGE\textbf{ Can Web Technologies Help R Generate }
  \linebreak
  \LARGE\textbf{ Print Quality Graphics? }
  \vspace{10mm} 
\end{center}

#+BEGIN_center 
#+ATTR_LATEX: :width 6.5in  
[[/project/resources/img/example_latex_graphic.pdf]]
\color{green}
\large\textsf{NOTE: Image to be updated with better example}
#+END_center 

\begin{center}
  \sffamily  
  \vspace{20mm} 
  \normalsize\textit{CompSci 791: Research Paper [Working version]}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{Kane Cullimore}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{\today}
\end{center}

\thispagestyle{empty}

\newpage 

\begin{abstract}  
\sffamily  
\vspace{2mm}
\noindent  
Abstract paragraph to cover the following main topics:
\begin{itemize}
\item Introduction and problem description
\item layoutEngine and its limitations
\item RSelenium backend
\item NodeJS backend
\item Future suggestions
\end{itemize}

\vspace{5mm}
\noindent  
\textbf{Document Structure}
  
\vspace{2mm}
\noindent  
This report is organized in the following way:
\begin{itemize}
\item A problem definition is given to explain the core functionality the layoutEngine library is provided
\item A brief explanation of how the layoutEngine is intended to be used along with its current short-comings is covered
\item The RSelenium layoutEngine back-end is introduced
\item The NodeJS layoutEngine back-end is introduced
\item A comparison of each back-end is given to identify areas of advancement
\item Finally, a review of the overall layoutEngine approach is given and compared to some existing R extensions
\end{itemize}
\vspace{5mm}
\textbf{Temporary Notes}  
  
\vspace{2mm}
\noindent
The planned size of document: 
\begin{itemize}
\item Background = 10 pages
\item RSelenium Backend = 10 pages
\item NodeJS Backend = 10 pages
\item Comparisons and Wrap-up = 10 pages
\end{itemize}

\vspace{2mm}
\noindent
Presentation: 
\begin{itemize}
\item Time ~ 10 mins with 4 mins Qs
\item Slide: Background and What problem it solves
\item Quick demo (with backup slide)
\item Slide: Diagram of lE system
\item Slide: Identification of lE limitations
\item Slide: New development
\item Demo of latest and greatest examples
\item Slide: Qs
\end{itemize}

\end{abstract}  
  
\newpage  
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

* Introduction

The *[[https://www.r-project.org/][R programming language]]* is a popular open-source statistical analysis tool. The language has many libraries that support sophisticated statistical techniques. Many of these rely on graphical output to communicate results. A strong appeal of this programming language is the ease at which its *core graphics system* (TODO: add glossary item) generates graphical output that is both accurate and effective at communicating this type of information. 

Few open-source alternatives offer an equivalent set of sophisticated statistics married to a flexible and powerful graphics system like R. The Python programming language is a strong competitor. However, its focus is more general purpose with fewer specialized statistics libraries that generate these types of graphics  (although it is catching up(??)). 

As the R programming language has grown in popularity so to has the number of specialized applications. One such use-case is the incorporation of the statistics based graphics within published articles. While the raw dots and dashes used to generate these graphics is of sufficient digital quality there are several fundamental publishing requirements which are not supported.

* Problem Description

The publishing industry has a long history dating back to the 15^{th} century when movable type printing was first invented. As the industry evolved within digital platforms it has brought with it a system of long-standing expectations for content. As a result, digital publications often have a myriad of requirements for graphics which are referred to in this report as **print quality graphics**. These requirements include *(1)* writing system and font specifications, *(2)* document layout and typesetting, *(3)* sophisticated content rendering, and *(4)* control over output resolution and file format.

R users have a powerful tool for generating statistics based graphics but they will struggle to support many of these requirements. Examples include (TODO: provide plot examples): 
  - Using multiple font types in the same graphic
  - Embedded tables and text-boxes with wrapped text
  - Complex layouts of text and graph components
  - TODO: add to or modify list

One existing solution to produce print quality graphics is to modify the R graphical output with external tools such as LaTeX or /Adobe Illustrator/. The user must either be proficient in both environments or have a specialist available to help. 

Another solution would rely on several existing R libraries. Such libraries offer bits of this functionality ad hoc. The user would remain within the R ecosystem but might need several libraries depending on the publishing requirements. This modular feature-set composition is the /standard R approach/ to extend its functionality. 

This research reviews an alternative approach where the print quality graphic is generated from within the R ecosystem with a single general purpose solution. This approach is central to the *layoutEngine* R library which incorporates *web technologies* to extend the functionality of the R graphics system. It is based on the understanding that web technologies and modern browsers have long supported the special needs of the publishing industry. Therefore, if the layoutEngine can successfully utilize the browsers graphics system, it can bring a full-suite of industry leading functionality to R users. 

This research does /not/ address the relative performance and functionality difference between the layoutEngine approach and the /standard R approach/. Rather, it /first/ explores the efficacy of this /layoutEngine approach/, and /second/, attempts to improve upon the implementation of the existing layoutEngine library to address several existing limitations. 

* The layoutEngine R Library

The intent of the *[[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][layoutEngine]]*[TODO: Add to References] R library is to extend R's graphical system by adopting functionality available in web technologies. To achieve this, its core functionality is to act as a high-level interface between R and a web browser and thereby tap into the rich feature set. While the library is available to review via the [[https://github.com/pmur002/layoutengine][layoutEngine repository]], it is still in development and not yet available in *[[https://CRAN.r-project.org/][CRAN]]*. 

** The Standard R Approach 

The /standard R approach/ to extending its functionality has been paramount to the success of open-source programming languages. Available libraries are loaded into the scope of an environment to gain functionality. If a larger feature set is need then several libraries are loaded as a type of modular system. There are many advantages to this approach and it is a key reason why these languages and user communities have thrived. 

Several *[[https://CRAN.r-project.org/web/packages/available_packages_by_name.html][available CRAN packages]]* offer functionality which meet some publishing requirements. Many of these libraries are well executed and perform admirably. The /[[https://github.com/wilkelab/ggtext][ggtext]]/ package enables multiple font types to be specified in the same graphic. The /[[https://github.com/thomasp85/patchwork][patchwork]]/ package offers a similar functionality specifically for arranging several ggplots with claims of increased simplicity and flexibility. In addition, the base package /[[https://stat.ethz.ch/R-manual/R-devel/library/grid/html/grid.layout.html][grid]]/ has a \texttt{layout} function which creates a \texttt{Grid} layout object that enables plots from different systems to be arranged together. Many other libraries extend R towards the realm of print quality graphics but no general purpose solution exists at this point in time.[TODO: add all to References] Together they establish that a need does exists for this type of extended functionality for R users. 

NOTE: Also references Paul's list per [[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][HTML Rendering article]]

This approach might eventually succeed in offering a general purpose solution to generate print quality graphics. However, several difficulties exist would first need to be overcome. First, the publishing requirements represent an extensive set of functionality. In addition, the variety of graphical output this must operate with is also large. As a result, the task of coordinating a suite of purpose-built libraries that is flexible enough to cover all scenarios would be significant. This is both difficult from both a developer and user perspective due to the large number of functions and objects to handle. 

** The layoutEngine Approach 

The /layoutEngine approach/ differs with the way it extends the functionality of R. It acts as a portal between the graphics system in R and a modern web browser so as to avoid reinventing the wheel. Instead it aims to adopt from an industry that has a long history supporting publishing requirements. This approach bypasses the need to build a complex system from the ground up. 
  
This approach aims to take advantage of preexisting technologies to generate print quality graphics. First, a user can rely on existing R libraries to generate HTML from R data objects which removes the need to translate between languages. Second, it adopts the sophistication of web technologies and modern web browsers that already support much of publishing industry requirements. In addition, since the R user will have unbridled access to these web technologies, the functionality of the R graphics system would be greatly extended. 

#+BEGIN_center 
#+ATTR_LATEX: :width 6.5in  
\textsf{Placeholder for Figure: layoutEngine Process}
#+END_center 

The figure above demonstrates the process of a general use-case. In summary, it starts with a graphic partially defined in R. This is converted to HTML where some additional definition could be added. The browser readable definition is transferred and loaded into a web browser where its layout and rendering engine generate the desired graphic in the browser window. A JavaScript function is then executed to calculate the position of each component on the page. This data is then sent back to R in CSV format where the layoutEngine will convert it to a R readable graphic object. This can then be displayed in the R graphics window or sent directly to an image file. 

** Solution Design 

The layoutEngine solution is designed as a two-component system. The layoutEngine *[[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html][primary library]]* is configured to interface with one of several available layoutEngine *[[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html#backends][backend libraries]]*[TODO: Add to References]. The primary library acts as the interface for R users while the backend library is the interface between R and the web browser. The solution design is separated into these components as much of the complexity exists in the backend library. This abstracts much of the complexity away from the user and allows improvements to be made to backend library with little impact to the user.

The primary library is a relatively simple and robust interface. It provides several helper functions to pass graphics-based data between the R user and layoutEngine backend. [TODO: extend description]

The backend library has many complexities to manage which present the primary challenge of this solution. The key mechanisms and complexities the backend library must contend with include:
- Variability in Host Machine 
  - Cross-platform system calls (macOS, Windows and Linux)
  - System and R dependencies
- Functionality
  - Locate and manage a modern web browser session
  - Send and receive data between a R session and web browser
  - Query and modify the web-page DOM [TODO: Add glossary term] 

There are three layoutEngine backends available for use with the layoutEngine at the time of this research. These backends successfully demonstrate the viability of this approach. 

** Benefits  
*** General 
  - Integration of the image within other content that is accessible programmatically 
  - Not just an embedded graphic
  - HTML knows about the interior of the R graphic and is NOT just a dumb blob
  - Access to a huge amount of functionality of the web technology stack
  - Web Tech is a vibrant community 
  - Browsers are extremely sophisticated and competitively being enhanced each year
  - Take advantage of the large variety of packages and methods that currently generaate HTML
    - Knitr (markdown?)
    - xtable
    - htmltools (RStudio https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html#pkg:htmltools)
    - Others?

- [[https://www.stat.auckland.ac.nz/~paul/Reports/HTML/layoutengine/layoutengine.html#backends][layoutEngine Backends]]

*** DOM Backend
- [TODO]
- Based on Paul's DOM package
- Live visual feedback for debugging, reviewing output
- Access to latest web browser and therefore latest HTML, CSS and JS specs

*** PhantomJS Backend
- [TODO]
- Simple, lightweight, few dependencies
- Per Ref
  - Based on WebKit browser engine (Apple from Chrome)
  - Does not require a GUI and performs layout off-screen

*** CSSBox Backend
- Per Ref
  - Based on CSSBox Java library 
  - Generates HTML layout information directly (i.e. standalone HTML layout engine)
  - Generates information for every line of text after layout which is better than most web browsers
- [TODO: get some feedback on this from Paul]


** Limitations
*** General 
  - Have to learn and write in HTML/CSS/JS
  - Security layer around using a browser 
  - System dependencies across all OS is trouble
  - Font managing software customized per OS
  - Per Ref
    - Cairo-based R graphics devices (and pdf & postscript)
    - Matching or converting X11 fonts for the X11 device to fonts the layout backends can use would be hard
    - Support for native Windows and MacOS graphics devices
    - Smallish list of CSS that is support in layoutEngine currently do nothing when pushed back to R from the backend
    - Issues with hyphens in CSS (as string variables in R)
    - Pixel resolution compatibility (resolution of graphics device should be set to 96 dpi) 
    - Not a fast process (rendering HTMl) => speed cost for expanded functionality
 


*** DOM Backend
- [TODO]
- Default browser opens every call
- Per Ref
  - See article about managing font types 

*** PhantomJS Backend
- [TODO]
- Lack of visual feedback
- No longer developed so will eventually lose support
- Based on older WebKit engine so behind on HTML and CSS specs 

*** CSSBox Backend
- Per Ref
  - Have to keep track of levels of accuracy based on what device HTML will be rendered on
  - Lags browsers support of web standards (modern CSS specifically)
- [TODO]



\newpage   
* layoutEngine Development

** Objectives

The viability of the layoutEngine approach is still being explored and it is the layoutEngine backend where the majority of the limitations reside. There are several existing back-ends however each has certain limitations that must be rectified before community adoption is possible. 

This report introduces two newly developed layoutEngine back-ends' which attempt to address the limitations of the existing designs. One relies on a *[[https://www.selenium.dev/documentation/en/][Selenium]]* server hosted within a *[[https://www.docker.com/resources/what-container][Docker container]]* container. The second is a custom *[[https://www.docker.com/resources/what-container][NodeJS]]* server also hosted with Docker. 


** Requirements

The backend must support a browser compatible communication protocol. Data must be transferred between R and the browser in both directions. The backend must first send the raw HTML based data to the browser. It must 

**** Explain improvements are needed with the *backend*
**** What does the *backend* need to achieve? 
**** What solution designs were considered? 
**** How do these compare to each other? 
**** What (and why) were the two *backend* designs chosen?

\newpage
* RSelenium Backend
** Solution Design

** Benefits
** Limitations

\newpage
* NodeJS Backend
** Solution Design
** Benefits
** Limitations

\newpage
* Comparison
**** Summary of solution features, benefits and limitations 
**** How do they rank with the existing *backends*? 

\newpage
* Recommendations
**** Overview of layoutEngine as a solution to generating print quality graphics
**** Do the new backends improve its performance? 
**** Where should future development work concentrate? 

\newpage
\appendix
\addappheadtotoc

* Appendix
\sffamily  
\setlength{\parindent}{0em}    
** Development Environment

A single Docker container is used to perform research, experimentation, R package development and documentation. This environment was chosen to easily share the development content with others for collaboration and feedback. It will also ensure that any future return to this research can be resurrected with a working code-base independent of software changes.  
   
 
The report and R development have been performed within Emacs and ESS environment inside of the Docker container. The report is written within the Emacs org-mode markdown language which abstracts some LaTeX syntax while also providing literate programming options which are more flexible than generic markdown or Rmarkdown.  
  
    
Some basic Docker and Emacs commands are provided to walk the user through some of aspects of the build and editing processes. 


*** Docker container description  
  

_Overview_: The Docker container is publicly available on [[https://hub.docker.com/][Docker Hub]] with the following image name \textbf{kcull\textbackslash dom\_r}. The container is built from the Ubuntu 18.04 image and has R 3.6.1 and Emacs 26.3 installed. The container has been configured to run Emacs in its GUI environment on the host machine. 
  
\noindent
_User and Home Directory_: The user is logged in as a sudo-user with \texttt{/home/user/} as the $HOME directory. The sudo password is "password." The working directory is \texttt{/project/} which both the shell and Emacs will initialize into. 

\noindent
_Directory Organization_: The project is organized into 2 main directories which are each linked to github repositories. Directory 1 is the forked \texttt{DOM} package which is extended per this research. Directory 2 is the research effort which contains the experimental code and files used to create this report. Both directories should be created and maintained on the host machine and then connected to the Docker container with a \textbf{bind mount} option when the container is running. 
  
\noindent
_Directory Hierarchy_:  
  
#+BEGIN_SRC bash :results none :exports code  
# Emacs configuration files   
/home/user/.emacs.d/ 
# Github repository for research paper
/project/
# Github repository for layoutEngine
/opt/layoutengine
# Experimental code for layoutEngineRSelenium
/opt/layoutenginerselenium
# Experimental code for layoutEngineNodeJS
/opt/layoutenginenodejs
#+END_SRC  
  

 
*** Host setup and Docker run instructions 

The following instructions are provided to recreate the development environment. This has only been tested from within a host machine running Ubuntu 18.04 but is assumed to be compatible with other Debian derivatives. The Dockerfile used to build the container is supplied which should enable the necessary tweaks to support other host machine environments. 

\setlength{\parindent}{2em}  
    
1 - Ensure docker and git are installed and correctly configured to download the docker image and clone repositories.  

2 - Obtain access to the private github repository, [[https://github.com/kcullimore/DOM_research]], for the research content by emailing myself at <kane@ia.house>. 

3 - Create a working directory on the host machine and clone each github repositories as shown below:  
  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Example folder structure  
mkdir /home/$USER/project
## Clone repositories
git clone git@github.com:kcullimore/DOM_research.git /home/$USER/project
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
4 - Run the following commands within the host terminal but first ensure the target directories are correct per Step 3 (i.e. verify source= \textbf{/home/\$USER/proj...} is correct). 

  
\BeforeBeginEnvironment{}{\begin{shaded}
#+BEGIN_SRC bash :results none :exports code  
## Open host machine devices to container (only need to do once per reboot)
xhost +local:
## Run docker container linked to directories with bind-mount  ------------------
docker run --rm -it \
       --network host \
       --env DISPLAY=unix$DISPLAY \
       --volume /tmp/.X11-unix:/tmp/.X11-unix \
       --mount type=bind,source=/home/$USER/project/,target=/project/ \
       --name layoutEngine-test \
       kcull/layoutEngine-research:latest 
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
\newpage  

5 - Once the docker container is up and running verify folder structure has correctly mapped the host directories.  
  
6 - Open Emacs in the container's terminal: \texttt{\$ Emacs}. The host should launch Emacs in its GUI form (i.e. not within the shell). If this doesn't occur verify steps 4 were followed thoroughly (NOTE: After reboot the display device will have to be provided access again with the \texttt{\$ xhost +local: command). 

7 - From within Emacs perform the following operations to open and recreate the current report 
  
- Opens Treemacs with \texttt{M-0}
- Open folder structure to \texttt{./../../paper/} with Tab-Enter or Mouse  
- Open org-mode markdown file \texttt{/paper\_working.org} with Enter or Mouse double-click 
- Make some edits to the file and save with \texttt{C-x C-s}    
- Launch Export Dispatcher menu with \texttt{C-c C-e}  
- Create new PDF file with \texttt{C-l C-o}  
  
8 - The PDF should have opened automatically which you can scroll through with arrow keys or the mouse scroll wheel.  Use \texttt{q} key to minimize the PDF buffer.  
  
9 - Close Emacs with \texttt{C-x C-c} and exit the container by typing \texttt{exit} at the terminal. 

10 - Navigate to the project directory on the host machine and verify the new PDF and edited org-mode file were correctly saved. 

11 - If the above worked the project appears to be correctly established on the host machine.  
  

*** Emacs within Docker Container 
  
\setlength{\parindent}{0em}  
    
_Emacs Terminology_  
  
- \textbf{buffer:} 'Screen' or 'window' user operates within  
- \textbf{marking:} Highlighting region of window  
  
 
Often used commands can be found at [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf]].
  
  
 
_Customized keybindings_  
  
- Open emacs configuration file with \texttt{C-c e}  (Emacs must be restarted for changes)
- Expand all nested/hidden text within *.org file with \texttt{Shift-Tab Shift-Tab Shift-Tab}   
- Copy, cut and paste with standard keybindings per \textbf{Cua Mode}  
- Switch visual line wrap with \texttt{M-9}  
- Switch to truncate long-line view with \texttt{M-8}  
- Enter/Exit rectangle edit mode with \texttt{C-\string^}  
- Enter/Exit multi-edit mode by highlighting word and then \texttt{C-u}  
- Auto-indent R script (via ESS) by highlighting buffer with \texttt{C-x h} and then \textt{C-M-\}
  
  
_Document Export_ 
  
When a PDF version of the document is produced a standard TeX file (*.tex) is also produced after transpilation. This TeX file can be edited and used with a standard LaTeX command: \texttt{latex report.tex}.  
  
 

To be continued...
  
\newpage
** Org-mode examples 

*** Font definitions 
\setlength{\parindent}{0em}  
  

Using LaTeX fontspec package \cite{type01}
  
\sffamily
_Sans_  
  
Internet based applications are an increasingly popular way to communicate and interact with complex data. 
  
\sffamily\itshape 
_Sans italic_  
   
Internet based applications are an increasingly popular way to communicate and interact wtih complex data. 
   
\sffamily\itshape\bfseries 
_Sans italic bold_  
   
This might include a business application that assist employees unverstand the current state of the market.
   
\normalfont 
_Serif_   
  
 It might also include a news website communicating techincal details from a story such census data. 
  
\normalfont\itshape 
_Serif italic_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont\itshape\bfseries    
_Serif italic bold_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\normalfont
\ttfamily    
_Mono type_   
  
 It might also include a news website communicating techincal details from a story such census data.  

\bfseries
_Mono Bold type_

\texttt{\bfseries The quick brown fox 012456789}

\normalfont
\sffamily  
  


\newpage  
*** Sample R code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC R :exports code
##*******10********20********30********40********50********60********70********80
## Problem 2: START => Optical Illusion Example
##*******10********20********30********40********50********60********70********80
## Generate pdf file of plot (capture ends with dev.off() below)
pdf("prob-02.pdf", width = 3, height = 6)
## Create theta values  for each line segments (i.e. 180 degs / 4 = 45 segments)
## Remove elements in the center of vector (i.e. 80-100 degree section)
theta <- seq(0, pi, length = 45)[-(20:26)]
## Set parameters to be used in plot() (R = dummy radius, B = slope of lines)
R <- 1
B <- sin(theta) / cos(theta)
## Setup plot space and define coordinate axes (also remove 'edge buffer')
plot.new()
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.window(xlim = c(-R, R), ylim = c(-R, R), asp = 1)
## Create the black line segments
for (i in 1:length(B)) abline(a = 0, b = B[i], lwd = 2)
## Create the 2 red vertical lines
abline(v = c(-R/2, R/2), col = "red", lwd = 4)
## Stop image capture
invisible(dev.off())
##*******10********20********30********40********50********60********70********80
## Problem 2: END
##*******10********20********30********40********50********60********70********80


#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}
  
  


\newpage  
*** Sample HTML code highlighting    
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC html :exports code
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1,
	    maximum-scale=1.0, user-scalable=0"
    />
    <!-- favicon -->
  </head>
  <body>
    <title>DOM - Testing Application</title>
    <div id="AppDiv" class="app-div"></div>
  </body>
</html>

#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

*** Sample CSS code highlighting      
  
\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC css :exports code
.iah-text-Raleway {
  font-family: 'Raleway', sans-serif;
  font-weight: 500;
}

.iah-text-black {
  font-family: 'Roboto Mono', monospace;
  font-weight: 500;
  font-size: 2em;
  overflow-wrap: break-word;
  margin: 10px;
  color: var(--iah-grey-dark);
}
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}

\newpage 
*** Sample JavaScript code highlighting  

\BeforeBeginEnvironment{}{\begin{shaded}  
#+NAME: Question-2
#+BEGIN_SRC javascript :exports code
var args = []; // Empty array, at first.
for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i])
} // Now 'args' is an array that holds your arguments.

// ES6 arrow function
var multiply = (x, y) => { return x * y; };

// Or even simpler
var multiply = (x, y) => x * y;    
#+END_SRC 
\AfterEndEnvironment{}{\end{shaded}  





\newpage  
* References
Murrell, P. (2018). "Rendering HTML Content in R Graphics" Technical Report 2018-13, Department of Statistics, The University of Auckland.


   
\begin{thebibliography}{bib}

\bibitem{type01}

package used to manage fonts within xelatex (or luatex)
fontspec: http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/fontspec/fontspec.pdf


\end{thebibliography}



\end{document}

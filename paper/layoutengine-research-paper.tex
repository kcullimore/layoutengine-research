% Created 2020-11-16 Mon 17:40
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[a4paper,top=2.5cm,bottom=2cm,left=1.75cm,right=1.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\usepackage{setspace}
\setlength{\parindent}{1.5em}
\setlength{\parskip}{0.5em}
\renewcommand{\baselinestretch}{1.25}
\usepackage{fontspec}
\usepackage{bold-extra}
\setmainfont{Taviraj}[Path = /project/research/resources/fonts/Taviraj/, Extension = .ttf, Scale=1.1, UprightFont = *-Light, BoldFont = *-SemiBold, ItalicFont = *-LightItalic, BoldItalicFont = *-SemiBoldItalic ]
\setsansfont{Montserrat}[Path = /project/research/resources/fonts/Montserrat/, Extension = .ttf, Scale=MatchLowercase, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic ]
\setmonofont{Inconsolata}[Path = /project/research/resources/fonts/Inconsolata/, Extension = .ttf, Scale=0.9, UprightFont = *-Regular, BoldFont = *-Bold]
\usepackage {titlesec}
\titleformat{\section}{\LARGE\sffamily\bfseries}{\thesection}{.9em}{}
\titleformat{\subsection}{\Large\sffamily\bfseries}{\thesubsection}{.9em}{}
\titleformat{\subsubsection}{\large\sffamily\bfseries}{\thesubsubsection}{.9em}{}
\usepackage{unicode-math}
\defaultfontfeatures{Ligatures=TeX}
\setmathfont{texgyrepagella-math}[Path = /project/research/resources/fonts/TexGyre/, Extension = .otf]
\usepackage{graphicx}
\usepackage{graphbox}
\usepackage{minted}
\usepackage{enumitem}
\setlist{nosep}
\setlist[itemize,1]{label={â–¶}}
\setlist[itemize,2]{label={$\rhd$}}
\setlist[itemize,3]{label={$\star$}}
\usepackage{xcolor}
\definecolor{shadecolor}{gray}{.96}
\chead{CS-791}
\lhead{\today}
\rhead{Kane Cullimore}
\date{}
\title{}
\hypersetup{
 pdfauthor={Kane Cullimore (ID 286367861)},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

f
\begin{document}

\begin{center}
  \LARGE\textbf{ Can Web Technologies Help R Generate }
  \linebreak
  \LARGE\textbf{ Print Quality Graphics? }
  \vspace{10mm} 
\end{center}

\begin{center}
\begin{center}
\includegraphics[width=6.5in]{/project/research/resources/img/example_latex_graphic.pdf}
\end{center}
\color{green}
\large\textsf{NOTE: Image to be updated with better example}
\end{center}

\begin{center}
  \sffamily  
  \vspace{20mm} 
  \normalsize\textit{CompSci 791: Research Paper [Working version]}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{Kane Cullimore}
  \vspace{5mm}
  \linebreak  
  \normalsize\textit{\today}
\end{center}

\thispagestyle{empty}

\newpage 

\begin{abstract}  
\sffamily  
\vspace{2mm}
\noindent  
Abstract paragraph to cover the following main topics:
\begin{itemize}
\item Introduction and problem description
\item layoutEngine and its limitations
\item RSelenium backend
\item NodeJS backend
\item Future suggestions
\end{itemize}

\vspace{5mm}
\noindent  
\textbf{Document Structure}
  
\vspace{2mm}
\noindent  
This report is organized in the following way:
\begin{itemize}
\item A problem definition is given to explain the core functionality the layoutEngine library is provided
\item A brief explanation of how the layoutEngine is intended to be used along with its current short-comings is covered
\item The RSelenium layoutEngine back-end is introduced
\item The NodeJS layoutEngine back-end is introduced
\item A comparison of each back-end is given to identify areas of advancement
\item Finally, a review of the overall layoutEngine approach is given and compared to some existing R extensions
\end{itemize}
\vspace{5mm}
\textbf{Temporary Notes}  
  
\vspace{2mm}
\noindent
The planned size of document: 
\begin{itemize}
\item Background = 10 pages
\item RSelenium Backend = 10 pages
\item NodeJS Backend = 10 pages
\item Comparisons and Wrap-up = 10 pages
\end{itemize}

\vspace{2mm}
\noindent
Presentation: 
\begin{itemize}
\item Time ~ 10 mins with 4 mins Qs
\item Slide: Background and What problem it solves
\item Quick demo (with backup slide)
\item Slide: Diagram of lE system
\item Slide: Identification of lE limitations
\item Slide: New development
\item Demo of latest and greatest examples
\item Slide: Qs
\end{itemize}

\end{abstract}  

\newpage  
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

\section{Introduction}
\label{sec:orgfce715c}

The \textbf{\href{https://www.r-project.org/}{R programming language}} is a popular open-source statistical analysis tool. The language has many libraries that support sophisticated statistical techniques. Many of these rely on graphical output to communicate results. A strong appeal of this programming language is the ease at which its \textbf{core graphics system} (TODO: add glossary item) generates graphical output that is both accurate and effective at communicating this type of information. 

Few open-source alternatives offer an equivalent set of sophisticated statistical methods married with a flexible and powerful graphics system. The Python programming language is a strong competitor. However, its focus is more as general purpose programming language with fewer specialized statistics libraries that generate these types of graphic types with equivalent rigor. 

The number of specialized applications R is used within has grown with its popularity. One such use-case is the incorporation of the statistical graphic within published articles. While the raw dots and dashes used to generate these graphics is of sufficient digital quality there are several fundamental publishing requirements which are not supported.

\section{Problem Description}
\label{sec:org66503ca}

The publishing industry has a long history dating back to the 15\textsuperscript{th} century when movable type printing was first invented. As the industry integrated within digital media it has brought with it a system of long-standing expectations for content. As a result, digital publications often have a myriad of requirements for graphics which are referred to in this report as \textbf{\textbf{print quality graphics}}. 

Several of the more important requirements include \textbf{(1)} writing system and font specifications, \textbf{(2)} document layout and typesetting, \textbf{(3)} sophisticated content rendering, and \textbf{(4)} control over output resolution and file format.

R users have a powerful tool for generating statistics based graphics but they will struggle to support many of these requirements. Several examples are presented below which show features which are not currently possible with the core R graphics system.

\begin{center}
\begin{center}
\includegraphics[width=4in]{/project/research/code/examples/ex-1.png}
\end{center}
\textsf{Example 1: Using multiple font types in the same graphical component}
\end{center}

\begin{center}
\begin{center}
\includegraphics[width=2.5in]{/project/research/code/examples/ex-2.png}
\end{center}
\textsf{Example 2: Embedded graphics with wrapped text}
\end{center}


\begin{center}
\begin{center}
\includegraphics[width=2.5in]{/project/research/code/examples/ex-3.png}
\end{center}
\textsf{Example 3: Complex layouts of text and graph components}
\end{center}


An existing solution to produce print quality graphics is to modify the R graphical output with external tools such as \LaTeX{} or \emph{Adobe Illustrator}. The user must either be proficient in both environments or have a specialist available to help. 


\begin{center}
\begin{center}
\includegraphics[width=5.5in]{/project/research/resources/img/old-system-external.png}
\end{center}
\textsf{External Applications Used to Produce Print Quality Graphics}
\end{center}

Another solution would rely on several existing R libraries. Such libraries offer bits of this functionality ad hoc. The user would remain within the R ecosystem but might need several libraries depending on the publishing requirements. This modular feature-set composition is the \emph{standard R approach} to extend its functionality. 


\begin{center}
\begin{center}
\includegraphics[width=5.5in]{/project/research/resources/img/old-system-internal.png}
\end{center}
\textsf{Standard R Approach to Produce Print Quality Graphics}
\end{center}


This research explores an alternative approach, referred to as the \emph{layoutEngine approach}, which offers a general purpose solution to generate print quality graphics from within the R ecosystem. This approach is encapsulated by the layoutEngine R library which incorporates web technologies to extend the functionality of the R graphics system. 

The motivation of this approach is based on the understanding that web technologies and modern browsers have long supported the special needs of the publishing industry. As a result, there is much functionality to be gained by leveraging this technology. The layoutEngine intends to create access to a full-suite of industry leading functionality. This hinges on whether it can successfully utilize the browsers graphics system in an easy to use R package with accessible dependencies. 

Please note that this research does not address the relative performance and functionality difference between the \emph{layoutEngine approach} and the \emph{standard R approach}. Rather, it \emph{first} explores the efficacy of this \emph{layoutEngine approach}, and \emph{second}, attempts to improve upon the implementation of the existing layoutEngine library to address several existing limitations. 

\section{The layoutEngine R Library}
\label{sec:orgec04f5c}

The intent of the \textbf{\href{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html}{layoutEngine}}[TODO: Add to References] R library is to extend R's graphical system by adopting functionality available in web technologies. Its core functionality is to act as an interface between R and a web browser to provide access to the rich feature set. The library is available to review via the \href{https://github.com/pmur002/layoutengine}{layoutEngine repository} however it is still in development and not yet available in \textbf{\href{https://CRAN.r-project.org/}{CRAN}}. 

\subsection{The Standard R Approach}
\label{sec:org4eec99f}

The \emph{standard R approach} to its extend functionality is paramount to the success of open-source programming languages. Available libraries are freely shared within the community which can be loaded into the scope of an environment to gain specific functionality. If a broader feature set is needed then several libraries are loaded which acts as a modular system. There are many advantages to this approach and it is a key reason why these languages and user communities have thrived. 

Several \textbf{\href{https://CRAN.r-project.org/web/packages/available\_packages\_by\_name.html}{available CRAN packages}} offer functionality which meet some publishing requirements. Many of these libraries are well executed and perform admirably. The \emph{\href{https://github.com/wilkelab/ggtext}{ggtext}} package enables multiple font types to be specified in the same graphic. The \emph{\href{https://github.com/thomasp85/patchwork}{patchwork}} package offers a similar functionality specifically for arranging several ggplots with claims of increased simplicity and flexibility. In addition, the base package \emph{\href{https://stat.ethz.ch/R-manual/R-devel/library/grid/html/grid.layout.html}{grid}} has a \texttt{layout} function which creates a \texttt{Grid} layout object that enables plots from different systems to be arranged together. Many other libraries extend R towards the realm of print quality graphics but no general purpose solution exists at this point in time.[TODO: add all to References] Together they establish that a need does exists for this type of extended functionality for R users. 

NOTE: Also references Paul's list per \href{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html}{HTML Rendering article}

The standard R approach might eventually succeed in offering a general purpose solution to generate print quality graphics. However, several difficulties exist would first need to be overcome. First, the publishing requirements represent an extensive set of functionality. In addition, the variety of graphical output this must operate with is also large. As a result, the task of coordinating a suite of purpose-built libraries that is flexible enough to cover all scenarios would be significant. This is both difficult from both a developer and user perspective due to the large number of functions and objects to handle. 

\subsection{The layoutEngine Approach}
\label{sec:org8e27192}

The \emph{layoutEngine approach} differs with the way it extends the functionality of R. It acts as an interface between the graphics system in R and another technology ecosystem; the web browser. This general purpose solution attempts to adopt from an industry that has a long history supporting publishing requirements so as to avoid reinventing the wheel. 

This approach bypasses the need to build a complex general purpose solution from the ground up and instead employs existing tools. These tools are part of the web-based languages (HTML, CSS and JavaScript) and R packages which can be used generate HTML from R objects. The table below identifies some of these technologies which can be used to generate a print quality graphic.

\begin{center}
\sffamily\small
\begin{center}
\begin{tabular}{p{0.25\textwidth}p{0.5\textwidth}}
\textbf{Functionality} & \textbf{Technology}\\
\hline
Layout and Typesetting & HTML elements styled with CSS Grid or Flexbox\\
Font Type and Styling & CSS @font-face with traditional CSS styles\\
Text Wrapping & Standard HTM, CSS shape-outside\\
R to HTML Conversion & xtable, formattable, htmltools, gridSVG, rmarkdown, etc\ldots{}\\
 & \\
\end{tabular}
\end{center}
\end{center}

The simplified diagram below demonstrates how the layoutEngine is used for a general use-case. The graphic is first defined as an R object. This is converted to HTML where some additional definition could be added. The browser readable definition is transferred and loaded into a web browser. The browser's layout and rendering engine generates the desired graphic in the browser window. A JavaScript function is then executed to calculate the position of each component on the page. This data is then sent back to R in CSV format where the layoutEngine will convert it to a R readable graphic object. This can then be displayed in the R graphics window or sent directly to an image file. 


\begin{center}
\begin{center}
\includegraphics[width=5.5in]{/project/research/resources/img/layoutEngine-system.png}
\end{center}
\textsf{Produce Print Quality Graphics Using the layoutEngine}
\end{center}

\subsection{Solution Design}
\label{sec:org100d764}

The layoutEngine solution design is comprised of two components as shown in the figure blow. The \textbf{\href{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html}{layoutEngine}} is configured to interface with one of several available \textbf{\href{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html\#backends}{layoutEnging Backends}}[TODO: Add to References]. The layoutEngine acts as the interface for the R user while the layoutEngine Backend is the interface between R and the web browser. This solution was chosen as much of the complexity exists in the Backend. This abstracts much of the complexity away from the user and allows various Backend designs to be swapped out with little impact to the main layoutEngine interface.

\begin{center}
\begin{center}
\includegraphics[width=5.5in]{/project/research/resources/img/layoutEngine-system-context.png}
\end{center}
\textsf{layoutEngine Solution Design}
\end{center}

\subsubsection{layoutEngine Package}
\label{sec:orgfa78114}

The layoutEngine is responsible for handling all the web-based data to send to the layoutEngine Backend. It must also take the returned data from the Backend and render this within the R graphics display. A major piece of this involves locating the correct fonts within the host machine to ensure the browser calculations are made using the exact font specifications. 

\noindent  
Requirements: 
\begin{itemize}
\item Interface for R Users to execute commands and configure the Backend
\item Handling of web page content (HTML, CSS, Fonts, Assets)
\item Call of Backend primary interface
\item Handle returned layout calculation
\item Rendering of new content within R Graphics Display
\end{itemize}

\noindent
Challenges: 
\begin{itemize}
\item Ensuring ease-of-use for R Users by accepting various web-based content formats
\item Cross-platform access to system fonts
\item Support conversion of web-based graphic data to the R graphics display
\end{itemize}


\subsubsection{layoutEngine Backend Package}
\label{sec:org8e8c72e}

The layoutEngine Backend is where much of complexity exists required to interface with a web browser. Since there are many possible ways to implement this functionality it is contained within a separate R package. The main purpose of the Backend is to serve the R graphic to a browser, execute the layout calculation script and return data to the layoutEngine. The Backend contains the primary challenge of the \emph{layoutEngine Approach}.

\noindent
Requirements: 
\begin{itemize}
\item Locate and manage a modern web browser session
\item Send and receive data between a R session and web browser
\item Query and modify the web-page DOM [TODO: Add glossary term]
\end{itemize}

\noindent
Challenges: 
\begin{itemize}
\item Variability in Host Machine 
\begin{itemize}
\item Cross-platform system calls (macOS, Windows and Linux)
\item System and R dependencies
\end{itemize}
\end{itemize}


There are three layoutEngine backends available for use with the layoutEngine at the time of this research. These backends successfully demonstrate the viability of this approach. 

\subsection{Benefits}
\label{sec:org0b571ac}
\subsubsection{General}
\label{sec:orge5a7e71}
\begin{itemize}
\item Integration of the image within other content that is accessible programmatically
\item Not just an embedded graphic
\item HTML knows about the interior of the R graphic and is NOT just a dumb blob
\item Access to a huge amount of functionality of the web technology stack
\item Web Tech is a vibrant community
\item Browsers are extremely sophisticated and competitively being enhanced each year
\item Take advantage of the large variety of packages and methods that currently generaate HTML
\begin{itemize}
\item Knitr (markdown?)
\item xtable
\item htmltools (RStudio \url{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html\#pkg:htmltools})
\item Others?
\end{itemize}
\end{itemize}
\begin{itemize}
\item \href{https://www.stat.auckland.ac.nz/\~paul/Reports/HTML/layoutengine/layoutengine.html\#backends}{layoutEngine Backends}
\end{itemize}

\subsubsection{DOM Backend}
\label{sec:org7105ac0}
\begin{itemize}
\item\relax [TODO]
\item Based on Paul's DOM package
\item Live visual feedback for debugging, reviewing output
\item Access to latest web browser and therefore latest HTML, CSS and JS specs
\end{itemize}

\subsubsection{PhantomJS Backend}
\label{sec:orgf3982a4}
\begin{itemize}
\item\relax [TODO]
\item Simple, lightweight, few dependencies
\item Per Ref
\begin{itemize}
\item Based on WebKit browser engine (Apple from Chrome)
\item Does not require a GUI and performs layout off-screen
\end{itemize}
\end{itemize}

\subsubsection{CSSBox Backend}
\label{sec:orgd1f981b}
\begin{itemize}
\item Per Ref
\begin{itemize}
\item Based on CSSBox Java library
\item Generates HTML layout information directly (i.e. standalone HTML layout engine)
\item Generates information for every line of text after layout which is better than most web browsers
\end{itemize}
\item\relax [TODO: get some feedback on this from Paul]
\end{itemize}

\subsection{Limitations}
\label{sec:org594e4d3}
\subsubsection{General}
\label{sec:org85e8e4a}
\begin{itemize}
\item Have to learn and write in HTML/CSS/JS
\item Security layer around using a browser
\item System dependencies across all OS is trouble
\item Font managing software customized per OS
\item Per Ref
\begin{itemize}
\item Cairo-based R graphics devices (and pdf \& postscript)
\item Matching or converting X11 fonts for the X11 device to fonts the layout backends can use would be hard
\item Support for native Windows and MacOS graphics devices
\item Smallish list of CSS that is support in layoutEngine currently do nothing when pushed back to R from the backend
\item Issues with hyphens in CSS (as string variables in R)
\item Pixel resolution compatibility (resolution of graphics device should be set to 96 dpi)
\item Not a fast process (rendering HTMl) => speed cost for expanded functionality
\end{itemize}
\end{itemize}

\subsubsection{DOM Backend}
\label{sec:org727c29b}
\begin{itemize}
\item\relax [TODO]
\item Default browser opens every call
\item Per Ref
\begin{itemize}
\item See article about managing font types
\end{itemize}
\end{itemize}

\subsubsection{PhantomJS Backend}
\label{sec:org345bf38}
\begin{itemize}
\item\relax [TODO]
\item Lack of visual feedback
\item No longer developed so will eventually lose support
\item Based on older WebKit engine so behind on HTML and CSS specs
\end{itemize}

\subsubsection{CSSBox Backend}
\label{sec:org81c559f}
\begin{itemize}
\item Per Ref
\begin{itemize}
\item Have to keep track of levels of accuracy based on what device HTML will be rendered on
\item Lags browsers support of web standards (modern CSS specifically)
\end{itemize}
\item\relax [TODO]
\end{itemize}


\subsubsection{Summary}
\label{sec:org06b57c7}

The following list summarizes the desired requirements for a layoutEngine backend: 
\small
\begin{itemize}
\item \textbf{Cross Platform:} Compatibility with all major operating systems (Linux, MacOS and Windows)
\item \textbf{Simple Dependencies:} Simple installation with few dependencies that are consistent across platforms
\item \textbf{Industry Support:} Robust industry support of any incorporated tools, technologies and standards
\item \textbf{Modern Web Standards:}  Support for modern web standards including HTML, CSS and JavaScript
\item \textbf{Visual Feedback:} Ability to view graphics within live browser
\end{itemize}

\begin{center}
\sffamily\small
\begin{center}
\begin{tabular}{p{0.3\textwidth}p{0.15\textwidth}p{0.15\textwidth}p{0.15\textwidth}}
\textbf{Limitation} & \textbf{DOM} & \textbf{PhantomJS} & \textbf{CSSBox}\\
\hline
Cross Platform & Low & Low & Low\\
Simple Dependencies & Low & Low & Low\\
Industry Support & Low & None & Low\\
Modern Web Standards & Med & Low & Low\\
Visual Feedback & High & None & ?\\
 &  &  & \\
\end{tabular}
\end{center}
\end{center}


\newpage   
\section{layoutEngine Development}
\label{sec:orgc1cff96}

\subsection{Objectives}
\label{sec:org8322a77}

The viability of the layoutEngine approach is still being explored and it is the layoutEngine backend where the majority of the limitations reside. There are several existing backends ([TODO:] see reference) however each has certain limitations that must be rectified before community adoption is possible. 

This report introduces two newly developed layoutEngine backends which attempt to address the limitations of the existing designs. One relies on a \textbf{\href{https://www.selenium.dev/documentation/en/}{Selenium}} server hosted within a \textbf{\href{https://www.docker.com/resources/what-container}{Docker container}} container. The second is a custom \textbf{\href{https://www.docker.com/resources/what-container}{NodeJS}} server also hosted within a Docker container. 


\subsection{layoutEngine and Backend Interfaces}
\label{sec:orgae3d28a}

Development for a layoutEngine Backend requires meeting the interface requirements for the layoutEngine package itself. In the example below, the Backend is specified and then the layoutEngine \texttt{\bfseries grid.html()} function is called with the specified arguments. Since the Backend is isolated, this \emph{R User interface} remains the same for all Backends. 

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
## Load libraries for layoutEngine and Backend and set the Backend
library(layoutEngine)
library(layoutEngineRSelenium)
options(layoutEngine.backend=RSeleniumEngine)
## Basic example supplying HTML, FONTS, CSS, ASSETS
HTML <- c('<div class="content">',
	  '<h1>This is some simple text</h1>',
	  '</div>')
FONTS <- cssFontFamily("FreeMono")
CSS <- '.content {font-family: FreeMono; border: solid; width: 800px; height: 100px; display: flex; justify-content: right;}'
## Call layoutEngine
png("essential-example.png", width=800, height=100)
grid.html(html=HTML, fonts=FONTS, css=CSS)
dev.off()
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}

\begin{center}
\begin{center}
\includegraphics[width=4in]{/project/research/code/examples/essential-example.png}
\end{center}
\end{center}

The \emph{Backend interface} is contained within the engine.R component of all the Backends. This file specifies a \textbf{Layout} and \textbf{fontFile} function that is used to instantiate a layoutEngine Backend Engine object using the \texttt{\bfseries makeEngine()} function. The requirements and flexibility of this object is documented within the \href{https://github.com/pmur002/layoutengine/blob/master/man/makeEngine.Rd}{layoutEngine::makeEngine() help page}. 

The \texttt{\bfseries layout} argument is the minimum requirement needed to instantiate Backend object. This function should perform take the supplied web-page data and then layout the page with a layout engine. This engine is expected to be provided within a typical browser but as seen with the CSS-Box Backend solution can also be a non-typical implementation of a layout engine. 

Once the web-page layout has been performed within the browser (or equivalent), the next requirement is the layout is captured within a R readable form. This is a critical piece of the layoutEngine functionality. For this research, the script that executes this step was taken from the \href{https://github.com/pmur002/layoutenginedom/blob/master/inst/JS/layout.js}{DOM Backend}. In general, this JavaScript script updates the web-page DOM to isolate all text characters within a single bounding box. Once each element has its bounding box, the locations and content for each box is exported from the DOM and transformed into CSV format. 

The layout CSV is then transferred back to the layoutEngine primary package where it redraws the graphic within the R graphic display. For all of this to work well, each component must be defined and tracked through this entire process. Of special concern is that of the specified fonts. Since all fonts vary dramatically in their sizes, the actual font files must be identified on the host machine and then transferred to the browser where they are incorporated into the web-page using the \texttt{\bfseries @font-face} CSS feature.

The layoutEngine Backend has much flexibility in the way it can be implemented provided this core functionality is provided. In general, these minimum requirements of the \texttt{\bfseries layout} function include: 
\begin{enumerate}
\item Start up a server used to host the web-page
\item Find the specified font files within the host system
\item Copy asset files to the server (fonts, images, embedded HTML, etc)
\item Open a web browser
\item Serve the web-page
\item Execute the layout calculation script within the browser
\item Send the returned CSV back to the layoutEngine
\end{enumerate}


\subsection{Technical Requirements}
\label{sec:orgfe09e25}

The layoutEngine Backend must meet several key technical requirements to adequately perform the necessary functions as outline in the previous section. These requirements can be addressed in a variety of ways as is evident in comparing the existing Backends ([TODO:] see reference). 

Technical requirements have been categorized to improve the ease of comparison. 

\subsubsection{Locally Hosted Server}
\label{sec:org71dae37}

\begin{itemize}
\item Live refresh of the browser upon updates to the DOM as a debugging tool
\begin{itemize}
\item Server to host web-page
\end{itemize}
\end{itemize}

\subsubsection{Browser Integration}
\label{sec:org32e3c3f}

\begin{itemize}
\item Maintain a single web browser instance for each layoutEngine call to prevent multiple browsers from sending layout calculations back to R
\item Use of latest web browser to ensure ability to utilize the best features of HTML, CSS and JavaScript as they become available
\begin{itemize}
\item Control of browser
\begin{itemize}
\item Automated (Selenium, or ``open'' call)
\item Manual control
\end{itemize}
\item Access to latest web technologies
\end{itemize}
\end{itemize}

\subsubsection{Bi-directional Communication}
\label{sec:org0c59a09}

The backend must support a browser compatible communication protocol. Data must be transferred between R and the browser in both directions. The backend must first send the raw HTML based data to the browser. It must 
\begin{itemize}
\item Communication Protocol
\begin{itemize}
\item Access to webpage to POST and GET
\end{itemize}
\end{itemize}
\begin{itemize}
\item Has to support the transfer information in both directions
\begin{itemize}
\item To the browser
\begin{itemize}
\item Asset files such as images and font files to the hosted webpage from the host machine
\item DOM components from the R layoutEngine call
\item Call to execute the layout calculation script
\end{itemize}
\item From the browser
\begin{itemize}
\item Either request or accept the layout calculation CSV as a file or in memory data
\end{itemize}
\end{itemize}
\item Control of DOM
\begin{itemize}
\item Add content to the page
\item Execute a JavaScript script and send the contents back
\end{itemize}
\end{itemize}

\subsubsection{Installation Requirements}
\label{sec:org09dcc4c}

\begin{itemize}
\item Few dependencies on other development teams for critical components that might either create bugs or prevent the support of the latest web technologies
\item As simple implementation as possible to 
\begin{itemize}
\item reduce the weight of the installed package
\item Enable easy future support or extensions by others
\item Provide as few opportunities for issues, bugs, etc and improve the maintainability and comprehension by other contributors to the project
\end{itemize}
\item Cross platform support
\begin{itemize}
\item Reduce the dependencies of OS specific packages to reduce the number cross-platform issues
\end{itemize}
\item No security vulnerabilities 
\begin{itemize}
\item Opening up graphics device or network access of the host machine
\item Cross-platform support
\begin{itemize}
\item Installation dependencies
\item Graphics device usage
\end{itemize}
\end{itemize}
\end{itemize}

\subsubsection{Performance \& Maintainability}
\label{sec:org4582111}

\begin{itemize}
\item While not a high-priority, there should not be a large performance hit for the full function call
\begin{itemize}
\item Performance
\item Bugs / Issues
\item Low dependencies on other embedded technologies
\item Ease of support and maintenance by other contributors
\end{itemize}
\end{itemize}



\subsection{Target Enhancements}
\label{sec:org55fd095}

\subsubsection{Cross Platform}
\label{sec:orgef94ff9}

An emphasis is placed on new layoutEngine backends to support all three major platforms (Linux, MacOS and Windows). While the existing backends prove the viability of the layoutEngine functionality it is deemed absolutely necessary for the package to be easily used on all platforms. There is little chance the package would be found useful across the industry if it were only available on Linux platforms. A primary reason for this being that a majority of users are on either Windows or MacOS. 

\subsubsection{Simple Dependencies}
\label{sec:org6a89efb}

Secondary to cross platform support, the backend must also have relatively simple installation requirements for all platforms. The intention here is to improve the user experience by making the installation as easy as possible. In addition, with fewer requirements there is less opportunities for future incompatibilities to arise.

\subsubsection{Industry Support}
\label{sec:org74816a6}

It is critical that any technologies that are incorporated into the layoutEngine backend have development support into the future. The more common and widely used such technologies are the less likely there will be technical issues as other parts of the ecosystem advance. 

\subsubsection{Modern Web Standards}
\label{sec:org50a408e}

It is preferred the backend design is able to support modern web standards for \textbf{Web Design and Applications} as defined by \href{https://www.w3.org/standards/webdesign/}{W3C}. If the latest and greatest standards are not fully supported then an acceptable lag of 1 to 2 years from the most recent release. This feature should be considered as relatively important as many users will be turned off from too much lag between what is seen as industry standard versus cutting edge. 

\subsubsection{Visual Feedback}
\label{sec:org8732c8f}

It should be considered valuable to have access to a live browser for several reasons. Although headless browsers might be considered more easily implemented there is significant value in being able to see the graphical output within the browser. For example, the user can see quickly identify any discrepancies between in supported web technologies between the browser and R graphics display.


\newpage
\section{RSelenium Backend}
\label{sec:org55e0829}

The RSelenium backend has been developed with the use of two preexisting technologies. The first is the \textbf{\href{https://www.selenium.dev/}{Selenium WebDriver}} which is a robust browser automation tool. The second is the \textbf{\href{https://cran.r-project.org/web/packages/RSelenium/index.html}{RSelenium R library}} which provides an interface to the Selenium WebDriver from within R. 

The primary interest in using Selenium is that is a powerful and popular tool that offers a more robust platform to control a web browser. The fact the RSelenium library allowed for easy use of this tool off-the-shelf further increased its appeal. While the benefits for this solution design are significant there are also several limitations (or downsides) to its use. 

This section first presents the solution design of the layoutEngine backend using Selenium. This is then followed by a review of the benefits and limitations of the design. 

\subsubsection{Overview}
\label{sec:org0fc393d}

The motivation behind the RSelenium Backend package includes the following: 
\begin{itemize}
\item Selenium Server 
\begin{itemize}
\item Robust solution that offers a large set of ways to control a browser
\item Strong technical community with evidence of future support due to wide industry use
\item Support of docker containers
\item Docker container includes controlled web browser types which improves consistency
\item Direct access to the webpage DOM via the Selenium server commands
\end{itemize}
\item RSelenium
\begin{itemize}
\item R interface to Selenium Server already exists
\item Tests shows relatively simple controls
\end{itemize}
\end{itemize}


\subsubsection{Solution Design}
\label{sec:orgc1e435c}


\begin{itemize}
\item RSelenium R Package
\item Selenium Docker images
\item Docker container
\item Browser launches from docker container (good and bad)
\end{itemize}



\begin{center}
\begin{center}
\includegraphics[width=6.5in]{/project/research/resources/img/rselenium-backend.png}
\end{center}
\textsf{RSelenium Backend Design}
\end{center}

\begin{enumerate}
\item RSelenium Backend Arguments
\label{sec:org430efe1}

\ttfamily   
\begin{itemize}
\item - url='127.0.0.1'
\item - portRS=4444
\item - portClient=4444
\item - network='bridge'
\item - shm\textunderscore size='1g'
\item - browser\textunderscore type='firefox'
\item - headless=FALSE
\item - image\textunderscore request=NULL
\item - fresh\textunderscore pull=FALSE
\end{itemize}

\normalfont
\item layoutEngineRSelenium Backend Setup
\label{sec:orge6be2ab}

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
library(layoutEngine)
library(layoutEngineRSelenium)
options(layoutEngine.backend=RSeleniumEngine)
## Firefox Selenium docker image
firefox_build <- "3.141.59-20200525"
firefox_image <- paste0("selenium/standalone-firefox-debug:", firefox_build)
## Chrome Selenium docker image
# chrome_build <- "3.141.59-20200525"
# chrome_image <- paste0("selenium/standalone-chrome-debug:", chrome_build)
## Select which image to test
test <- list(name="firefox", image=firefox_image)
# test <- list(name="chrome", image=chrome_image)
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}


\item Docker Container Component
\label{sec:org6317cd1}


The Selenium Docker container call \texttt{\bfseries dockerContainer()} will start up the Selenium Docker container per the argument settings. It also has methods to get status and stop the container. 

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
## User settings for component test
settings <- list(url="127.0.0.1", portRS=4444, portClient="4444", network="bridge", shm_size="1g",                      
		 browser_type=test$name, headless=FALSE, image_request=test$image, fresh_pull=FALSE)
## Setup RSelenium Backend Docker container based on user settings
container <- dockerContainer(settings)
## Run the RSelenium docker container 
container$run()
## Get RSelenium docker container status
container$getInfo()
## Stop and delete the RSelenium Docker container 
container$close()
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}



\item Selenium Server Component
\label{sec:org2a8cba9}

The Selenium server call \texttt{\bfseries rSServer()} will start up the Selenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 


\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
## Setup RSelenium Backend Selenium server hosted on the docker container
RSServer <- rSServer(settings)
## Get Selenium server status
RSServer$getStatus()
## Open a browser instance hosted within the Docker container
RSServer$open()
## Close RSelenium Backend Selenium server hosted on the docker container
RSServer$close()
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}


\item Selenium Browser Session Component
\label{sec:org4860028}

The RSelenium Server call \texttt{\bfseries rSServer()} will start up the RSelenium Docker container with the  \texttt{\bfseries dockerContainer()} call shown above. It will also setup the RSelenium server hosted within the Docker container with the  \texttt{\bfseries open()} method. It also has methods to get status and stop the container. 


\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
## The outer most component starts all encapusalated components
RSSession <- rSSSession(url="127.0.0.1", portRS=4444, portClient="4444", network="bridge", shm_size="1g",
			browser_type=test$name, headless=FALSE, image_request=test$image, fresh_pull=FALSE)
## Open a browser instance hosted on a Selenium server within the Docker container
RSSession$open()
## Get status of all the components
RSSession$getStatus()
## Close all components (browser session, server and Docker container)
RSSession$close()
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}
\end{enumerate}


\subsubsection{Benefits}
\label{sec:orgb7598aa}

The backend performs quite well when working properly. 
\begin{itemize}
\item The use of the Selenium server and browser session made it easy to ensure only a single browser session was used for each R layoutEngine call.
\item The communication protocol used to control the Selenium browser's DOM was abstracted away from our development efforts. Since the Selenium server's primary functionality is offering tight controls of a browser we were able to take full advantage of this. This meant that JavaScript DOM scripting methods can be directly applied to modify its content without the need for worrying about using a communication protocol such at HTTP or a WebSocket.
\item Since we can directly modify the contents of the webpage DOM via the Selenium server controls we see live updates in the browser without having to refresh the page. This both improves the user feedback of the using the browser as a debugging device and adds the ability to execute the layout calculation script immediately upon the DOM update.
\item Stand alone server seperate from R
\end{itemize}

\subsubsection{Limitations}
\label{sec:orgf2d702d}

Some downsides of the RSelenium Backend include the following: 
\begin{itemize}
\item Scheduling the start-up of the container, Selenium Server and then the web browser session created some difficulties
\item Time required to open the full stack was near 5-10 seconds
\item Opening the browser application hosted within the docker container in full mode (i.e. no headless) poses difficulties for Windows and MacOS due to the sharing of the host graphics system. It can be finicky to get this working on all host machines easily.
\item The browser version is controlled by the Selenium development team which must be supported via one of their docker images. This creates a dependency on this external development team to ensure the latest browsers (and therefore latest web specifications) can be maintained.
\item It was found that a latest docker image created a bug with the RSelenium R package that was no longer up to date. Dependencies on both the Selenium docker iamges and RSelenium R Package poses some risk of future bugs or lack of support for the latest features.
\end{itemize}





\subsubsection{Summary}
\label{sec:orga8b2d85}


In general, the RSelenium backend offers a simple way of controlling a browser. However, there are several issues that this approach presents to future development. As a result, it does not seem to be a robust solution to continue development with. 







\newpage
\section{NodeJS Backend}
\label{sec:org36ab29b}

\subsubsection{Overview}
\label{sec:org88f4d78}
The motivation behind the NodeJS Backend package includes the following:
\begin{itemize}
\item Building the server from scratch would result in very light-weight package
\item Easily customize the functionality of it to suit the layoutEngine
\item NodeJS is a very popular language with a large community and strong support into the future
\item Several Node packages/libraries can be used to take advantage of
\item Ability to stay at the very fore-front of web language support since we're in control of all depencies
\item Few risky dependencies (i.e. RSlenenium and Selenium images)
\item Easily work within Docker image for support multiple OS types via communication protocol such as WebSocket or HTTP API
\item Can extend functionality of the backend service in an endless variety
\end{itemize}


\subsubsection{Solution Design}
\label{sec:org4a82316}



\begin{center}
\begin{center}
\includegraphics[width=6.5in]{/project/research/resources/img/nodejs-backend.png}
\end{center}
\textsf{NodeJS Backend Design}
\end{center}


\begin{itemize}
\item Webpack Dev Server
\item Express Server
\item Web Socket
\item Docker Container
\end{itemize}


\subsubsection{Benefits}
\label{sec:org978bc7f}
\begin{itemize}
\item Ability to design server side functionality to extend the usefulness and robustness of the solution
\begin{itemize}
\item For example, transformations or formatting can be performed on the server before sending back to R
\item Very tight compatibiity between a Node server and the browser ensures strong solution design on that side
\item Aim would be to simplify the function calls as much as possible on the R interface
\end{itemize}
\item Live reload still exists via WebPack dev server
\item Lightweight dependencies
\item Local browser (good and bad)
\item Docker container
\item Stand alone server separate from R
\item Server could reside external to the host if there were ever a need or use-case for
\end{itemize}

\subsubsection{Limitations}
\label{sec:org0b87dc4}
\begin{itemize}
\item Have to implement communication protocol
\item Managing multiple browser and/or open tabs needs managing
\item Performance hit to stand-up docker container and node server
\item Unforeseen issues due to new design with little testing
\end{itemize}




\subsubsection{Summary}
\label{sec:org319fec3}


\newpage
\section{Comparison}
\label{sec:org3489f9c}
\begin{enumerate}
\item Summary of solution features, benefits and limitations
\label{sec:orgd10129f}
\item How do they rank with the existing \textbf{backends}?
\label{sec:org720c9f5}

\newpage
\end{enumerate}
\section{Recommendations}
\label{sec:orgf4cbbf7}
\begin{enumerate}
\item Overview of layoutEngine as a solution to generating print quality graphics
\label{sec:orge1bd44b}
\item Do the new backends improve its performance?
\label{sec:org7cae614}
\item Where should future development work concentrate?
\label{sec:org50c893b}

\newpage
\appendix
\addappheadtotoc
\end{enumerate}

\section{Appendix}
\label{sec:org31e8cbc}
\sffamily  
\setlength{\parindent}{0em}    
\subsection{Development Environment}
\label{sec:org1835c99}

A single Docker container is used to perform research, experimentation, R package development and documentation. This environment was chosen to easily share the development content with others for collaboration and feedback. It will also ensure that any future return to this research can be resurrected with a working code-base independent of software changes.  


The report and R development have been performed within Emacs and ESS environment inside of the Docker container. The report is written within the Emacs org-mode markdown language which abstracts some \LaTeX{} syntax while also providing literate programming options which are more flexible than generic markdown or Rmarkdown.  


Some basic Docker and Emacs commands are provided to walk the user through some of aspects of the build and editing processes. 


\subsubsection{Docker container description}
\label{sec:org8bdfd72}


\uline{Overview}: The Docker container is publicly available on \href{https://hub.docker.com/}{Docker Hub} with the following image name \textbf{kcull\textbackslash layoutengine-research}. The container is built from the Ubuntu 18.04 image and has R 3.6.3 and Emacs 27.1 installed. The container has been configured to run Emacs in its GUI environment on the host machine. 

\noindent
\uline{User and Home Directory}: The user is logged in as a sudo-user with \texttt{/home/user/} as the \$HOME directory. The sudo password is ``password.'' The working directory is \texttt{/project/} which both the shell and Emacs will initialize into. 

\noindent
\uline{Directory Organization}: The project also has the primary layoutEngine repositories cloned in the \texttt{\textbackslash opt} directory. 

\noindent
\uline{Directory Hierarchy}:  

\begin{minted}[breaklines=true,breakanywhere=true]{bash}
# Emacs configuration files   
/home/user/.emacs.d/ 
# Github repository for research paper
/project/
# Github repository for layoutEngine
/opt/layoutengine
# Github repository for layoutEngineDOM
/opt/layoutenginedom
# Experimental code for layoutEngineRSelenium
/opt/layoutenginerselenium
# Experimental code for layoutEngineNodeJS
/opt/layoutenginenodejs
\end{minted}



\subsubsection{Host setup and Docker run instructions}
\label{sec:org9f1e96f}

The following instructions are provided to recreate the development environment. This has only been tested from within a host machine running Ubuntu 18.04 but is assumed to be compatible with other Debian derivatives. 

\setlength{\parindent}{0em}  
\begin{itemize}
\item GitHub Repository: \href{https://github.com/kcullimore/layoutengine-research}{kcullimore/layoutengine-research}
\item Docker Image: \href{https://hub.docker.com/repository/docker/kcull/layoutengine-research}{kcull\textbackslash layoutengine-research}
\end{itemize}

\vspace{5mm}
1 - Download the docker image:

\begin{minted}[breaklines=true,breakanywhere=true]{bash}
$ docker pull kcull/layoutengine-research:latest
\end{minted}

2 - Create a working directory on the host machine and clone the github repository:

\begin{minted}[breaklines=true,breakanywhere=true]{bash}
$ mkdir /home/$USER/layoutengine-research
$ git clone git@github.com:kcullimore/layoutengine-research.git /home/$USER/layoutengine-research
\end{minted}

3 - Grant local access to your X server to allow Emacs to run in a local window and the run the docker container (setting is reset upon reboot):
\textbf{\textbf{Warning: this exposes your computer. Read more \href{https://wiki.archlinux.org/index.php/Xhost}{here}.}}  

\begin{minted}[breaklines=true,breakanywhere=true]{bash}
$ xhost +local:
\end{minted}

4 - Run the docker container: 

\begin{minted}[breaklines=true,breakanywhere=true]{bash}
$ docker run --rm -it \
	 --network host \
	 --privileged=true \
	 --env DISPLAY=unix$DISPLAY \
	 --volume /tmp/.X11-unix:/tmp/.X11-unix \
	 --volume /var/run/docker.sock:/var/run/docker.sock \
	 --mount type=bind,source=/home/$USER/layoutegine-research/,target=/project/ \
	 --name layoutengine-research \
	 kcull/layoutengine-research:latest
\end{minted}

5 - Once the docker container is up and running verify folder structure has correctly mapped the host directories.  

6 - Open Emacs in the container's terminal: \texttt{\$ Emacs}. The host should launch Emacs in its GUI form (i.e. not within the shell). If this doesn't occur verify steps 4 were followed thoroughly (NOTE: After reboot the display device will have to be provided access again with the \texttt\{$\backslash$$ xhost +local: command). 

7 - From within Emacs perform the following operations to open and recreate the current report 

\begin{itemize}
\item Opens Treemacs with \texttt{M-0}
\item Open folder structure to \texttt{/project/paper/} with Tab-Enter or Mouse
\item Open org-mode markdown file \texttt{layoutengine-research-paper.org} with Enter or Mouse double-click
\item Make some edits to the file and save with \texttt{C-x C-s}
\item Launch Export Dispatcher menu with \texttt{C-c C-e}
\item Create new PDF file with \texttt{C-l C-o}
\end{itemize}

8 - The PDF should have opened automatically which you can scroll through with arrow keys or the mouse scroll wheel.  Use \texttt{q} key to minimize the PDF buffer.  

9 - Close Emacs with \texttt{C-x C-c} and exit the container by typing \texttt{exit} at the terminal. 

10 - Navigate to the project directory on the host machine and verify the new PDF and edited org-mode file were correctly saved. 

11 - If the above worked the project appears to be correctly established on the host machine.  


\subsubsection{Emacs within Docker Container}
\label{sec:org6536829}

\setlength{\parindent}{0em}  

\uline{Emacs Terminology}  

\begin{itemize}
\item \textbf{buffer:} 'Screen' or 'window' user operates within
\item \textbf{marking:} Highlighting region of window
\end{itemize}


Often used commands can be found at \url{https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf}.



\uline{Customized keybindings}  

\begin{itemize}
\item Open emacs configuration file with \texttt{C-c e}  (Emacs must be restarted for changes)
\item Expand all nested/hidden text within *.org file with \texttt{Shift-Tab Shift-Tab Shift-Tab}
\item Copy, cut and paste with standard keybindings per \textbf{Cua Mode}
\item Switch visual line wrap with \texttt{M-9}
\item Switch to truncate long-line view with \texttt{M-8}
\item Enter/Exit rectangle edit mode with \texttt{C-\string^}
\item Enter/Exit multi-edit mode by highlighting word and then \texttt{C-u}
\item Auto-indent R script (via ESS) by highlighting buffer with \texttt{C-x h} and then \textt{C-M-\}
\end{itemize}


\uline{Document Export} 

When a PDF version of the document is produced a standard \TeX{} file (*.tex) is also produced after transpilation. This \TeX{} file can be edited and used with a standard \LaTeX{} command: \texttt{latex report.tex}.  



To be continued\ldots{}

\newpage
\subsection{Org-mode examples}
\label{sec:org226d40d}

\subsubsection{Font definitions}
\label{sec:org5a7996d}
\setlength{\parindent}{0em}  


Using \LaTeX{} fontspec package \cite{type01}

\sffamily
\uline{Sans}  

Internet based applications are an increasingly popular way to communicate and interact with complex data. 

\sffamily\itshape 
\uline{Sans italic}  

Internet based applications are an increasingly popular way to communicate and interact wtih complex data. 

\sffamily\itshape\bfseries 
\uline{Sans italic bold}  

This might include a business application that assist employees unverstand the current state of the market.

\normalfont 
\uline{Serif}   

It might also include a news website communicating techincal details from a story such census data. 

\normalfont\itshape 
\uline{Serif italic}   

It might also include a news website communicating techincal details from a story such census data.  

\normalfont\itshape\bfseries    
\uline{Serif italic bold}   

It might also include a news website communicating techincal details from a story such census data.  

\normalfont
\ttfamily    
\uline{Mono type}   

It might also include a news website communicating techincal details from a story such census data.  

\bfseries
\uline{Mono Bold type}

\texttt{\bfseries The quick brown fox 012456789}

\normalfont
\sffamily  



\newpage  
\subsubsection{Sample R code highlighting}
\label{sec:orgef6e674}

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{r}
##*******10********20********30********40********50********60********70********80
## Problem 2: START => Optical Illusion Example
##*******10********20********30********40********50********60********70********80
## Generate pdf file of plot (capture ends with dev.off() below)
pdf("prob-02.pdf", width = 3, height = 6)
## Create theta values  for each line segments (i.e. 180 degs / 4 = 45 segments)
## Remove elements in the center of vector (i.e. 80-100 degree section)
theta <- seq(0, pi, length = 45)[-(20:26)]
## Set parameters to be used in plot() (R = dummy radius, B = slope of lines)
R <- 1
B <- sin(theta) / cos(theta)
## Setup plot space and define coordinate axes (also remove 'edge buffer')
plot.new()
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.window(xlim = c(-R, R), ylim = c(-R, R), asp = 1)
## Create the black line segments
for (i in 1:length(B)) abline(a = 0, b = B[i], lwd = 2)
## Create the 2 red vertical lines
abline(v = c(-R/2, R/2), col = "red", lwd = 4)
## Stop image capture
invisible(dev.off())
##*******10********20********30********40********50********60********70********80
## Problem 2: END
##*******10********20********30********40********50********60********70********80


\end{minted}
\AfterEndEnvironment{}\{\end{shaded}




\newpage  
\subsubsection{Sample HTML code highlighting}
\label{sec:org84ff9e1}

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{html}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1,
	    maximum-scale=1.0, user-scalable=0"
    />
    <!-- favicon -->
  </head>
  <body>
    <title>DOM - Testing Application</title>
    <div id="AppDiv" class="app-div"></div>
  </body>
</html>

\end{minted}
\AfterEndEnvironment{}\{\end{shaded}

\subsubsection{Sample CSS code highlighting}
\label{sec:org62d6567}

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{css}
.iah-text-Raleway {
  font-family: 'Raleway', sans-serif;
  font-weight: 500;
}

.iah-text-black {
  font-family: 'Roboto Mono', monospace;
  font-weight: 500;
  font-size: 2em;
  overflow-wrap: break-word;
  margin: 10px;
  color: var(--iah-grey-dark);
}
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}

\newpage 
\subsubsection{Sample JavaScript code highlighting}
\label{sec:org765a520}

\BeforeBeginEnvironment{}\{\begin{shaded}  
\begin{minted}[breaklines=true,breakanywhere=true]{javascript}
var args = []; // Empty array, at first.
for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i])
} // Now 'args' is an array that holds your arguments.

// ES6 arrow function
var multiply = (x, y) => { return x * y; };

// Or even simpler
var multiply = (x, y) => x * y;    
\end{minted}
\AfterEndEnvironment{}\{\end{shaded}  





\newpage  
\section{References}
\label{sec:org0910b7b}
Murrell, P. (2018). ``Rendering HTML Content in R Graphics'' Technical Report 2018-13, Department of Statistics, The University of Auckland.



\begin{thebibliography}{bib}

\bibitem{type01}

package used to manage fonts within xelatex (or luatex)
fontspec: http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/fontspec/fontspec.pdf

\bibitem{type02}
docker socket solution
https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/

\end{thebibliography}



\end{document}
\section{Notes}
\label{sec:org33a3d17}

\subsection{Examples}
\label{sec:org11e7c62}

\begin{center}
\begin{tabular}{lll}
R Limitation & Internal Option & layoutEngine\\
\hline
Multiple fonts in single graphic & ggtext & \\
Text layout (wrapping, alignment, etc) & Manual, patchwork? & \\
Embedded ``live'' objects within graphics & Grid & \\
Stylized rendered content &  & \\
Wrap text around SVG &  & \\
Write text along path &  & \\
 &  & \\
\end{tabular}
\end{center}

\textbf{Datasets}

\begin{itemize}
\item \href{https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html\#O}{datasets}
\item library(help = ``datasets'')
\end{itemize}

\textbf{Libraries}
\begin{itemize}
\item Lattice
\item ggpolot
\item ggplot2
\item htmltools (RStudio)
\item htmlwidgets (RStudio)
\item svglite (RStudio)
\end{itemize}

\textbf{Plot types}
\begin{itemize}
\item Histogram (hist(), plot.histogram(), histogram())
\item Kernel density estimation (ksmooth(), densityplot())
\item Stem and leaf Plot (stem())
\item Scatterplot, (pairs(), plot(), smoothScatter(), xyplot() etc.)
\item Time series (tsplot())
\item Contour plots (contour(), contourplot(), levelplot())
\item Graph of a function of two variables evaluated on a grid(contourplot(), levelplot(), persp(), wireframe())
\item Graph multivariate data (splom(), parallelplot())
\item Greyscale (image())
\item Compare the sample distributions of two or more sets of data (bwplot(), stripplot(), qq(), etc.)
\item Graph Measurements with Labels (barchart(), dotplot(),piechart())
\item Graph the sample distribution of one set of data (histogram(),densityplot(), qqmath())
\item Graph three numerical variables (cloud(numeric1 âˆ¼ numeric2 * numeric3))
\item Smoothing techniques (loess(), lowess(), smooth.spline(), ns(), bs(), etc.)
\end{itemize}
\end{document}